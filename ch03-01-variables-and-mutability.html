<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Biến và tính khả biến - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a id="variables-and-mutability"></a></p>
<h2 id="biến-và-tính-khả-biến"><a class="header" href="#biến-và-tính-khả-biến">Biến và tính khả biến</a></h2>
<p>Như đã nhắc đến trong phần <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">“Storing Values with
Variables”</a><!-- ignore -->, mặc nhiên các biến
là không thể thay đổi giá trị (immutable). Đây là một trong nhiều cách Rust mang đến để giúp viết
ra những đoạn code an toàn và dễ dàng hoạt động song song. Tuy nhiên, bạn vẫn có các
tùy chọn để cho phép thay đổi giá trị các biến. Hãy cùng chúng tôi xem qua như thế
nào và vì sao Rust khuyến khích việc chặn thay đổi giá trị biến, và vì sao đôi khi
chúng ta vẫn phải bỏ chặn.</p>
<p>Khi một biến là bất biến (immutable), một khi đã gán cho nó một giá trị, bạn sẽ không
thể thay đổi giá trị đó nữa. Để minh họa điều này, hãy tạo ra một dự án mới
được gọi là <em>variables</em> trong thư mục <em>projects</em> bằng cách chạy câu lệnh <code>cargo new variables</code>.</p>
<p>Sau đó, trong thư mục <em>variables</em> mới tạo, mở file <em>src/main.rs</em> và thay thế code của nó với
đoạn sau (đoạn code này sẽ không thể dịch được ngay):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre>
<p>Lưu lại và chạy chương trình dùng <code>cargo run</code>. Bạn sẽ phải thấy một thông báo
liên quan đến lỗi bất biến, như được hiển thị dưới đây:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Ví dụ này cho thấy cách trình biên dịch giúp bạn tìm lỗi trong chương trình.
Các lỗi biên dịch có thể làm nản lòng, nhưng chúng thực sự mang ý nghĩa là chương
trình của bạn không an toàn khi thực hiện cái mà bạn yêu cầu nó thực hiện.
Chúng <em>không</em> có nghĩa bạn không phải là một lập trình viên tốt! Những Rustaceans
nhiều kinh nghiệm vẫn gặp các lỗi biên dịch.</p>
<p>Bạn nhận được thông báo <code>cannot assign twice to immutable variable `x`</code>,
vì bạn đã thử gán giá trị cho biến immutable <code>x</code> thêm một lần nữa.</p>
<p>Việc nhận được các lỗi biên dịch khi ta cố gắng thay đổi giá trị của một biến được
chỉ định là bất biến là rất quan trọng, nó là một trong những nguyên nhân hàng
đầu dẫn đến bug. Nếu một phần trong chương trình cho là biến đó sẽ không thay đổi
nhưng ở một phần khác lại gán một giá trị mới cho nó, rất có thể phần đầu tiên sẽ
không còn hoạt động như nó được thiết kế. Nguyên nhân gây lỗi này đôi khi rất khó
dò ra, đặc biệt nếu phần code thay đổi giá trị của biến chỉ <em>đôi khi</em> được thực hiện.
Trình dịch Rust bảo đảm khi bạn đã phát biểu rằng một biến sẽ không thể thay đổi, nó
sẽ thực sự không thay đổi, và bạn không cần phải tự kiểm soát việc đó. Như vậy
code của bạn sẽ dễ lý giải hơn.</p>
<p>Nhưng khả năng thay đổi giá trị cũng rất cần thiết, và làm cho việc viết code dễ dàng
hơn. Các biến mặc nhiên sẽ không thay đổi được; như bạn đã thấy trong <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">Chương
2</a><!-- ignore -->,
bạn có thể làm cho chúng thay đổi được giá trị bằng cách thêm <code>mut</code> vào phía trước
tên biến. Việc thêm <code>mut</code> cũng truyền đạt ý định cho những người đọc code trong tương lai
bằng cách chỉ ra rằng các phần khác của code sẽ thay đổi giá trị của biến này.</p>
<p>Lấy ví dụ, hãy thay đổi <em>src/main.rs</em> thành như sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>Giờ chạy chương trình, bạn sẽ nhận được nội dung sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Chúng ta được phép thay đổi giá trị gán cho <code>x</code> từ <code>5</code> thành <code>6</code> khi dùng <code>mut</code>.
Hơn hết, việc quyết định liệu có cho phép thay đổi hay không là do bạn và phụ thuộc
vào việc bạn nghĩ cách nào là rõ ràng nhất trong một trường hợp cụ thể.</p>
<p><a id="constants"></a></p>
<h3 id="hằng"><a class="header" href="#hằng">Hằng</a></h3>
<p>Tương tự với các biến không đổi, các hằng cũng là các giá trị được đặt tên và không được
phép thay đổi, tuy nhiên có một số điểm khác nhau.</p>
<p>Đầu tiên, bạn không được phép dùng <code>mut</code> với hằng. Các hằng không chỉ là mặc nhiên
bất biến - mà là luôn luôn bất biến. Bạn khai báo các hằng dùng từ khóa <code>const</code>
thay vì từ khóa <code>let</code>, và <em>phải</em> chỉ ra kiểu của hằng. Chúng ta sẽ nó thêm về
cover type và type annotation trong phần tiếp theo, <a href="ch03-02-data-types.html#data-types">“Các kiểu dữ liệu,”</a><!-- ignore -->
do vậy đừng lo về chi tiết bây giờ. Chỉ cần nhớ là bạn luôn phải chỉ ra kiểu.</p>
<p>Các hằng có thể được khai báo trong bất kỳ tầm vực nào, bao gồm phạm vi toàn cục (global),
điều này hữu ích với các giá trị mà bạn muốn truy cập từ nhiều đoạn code khác nhau.</p>
<p>Phần khác biệt cuối cùng là các hằng chỉ có thể được gán giá trị là một biểu thức
hằng, không thể là một giá trị mà chỉ có thể tính toán được khi chạy.</p>
<p>Đây là một ví dụ về khai báo hằng:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Tên của hằng là <code>THREE_HOURS_IN_SECONDS</code> và giá trị của nó là tích của 60 (số giây
trong một phút) với 60 (số phút trong một giờ) với (số giờ bạn muốn tính trong
chương trình này). Quy ước đặt tên hằng trong Rust là sử dụng tất cả ký tự in hoa,
các từ cách nhau bằng ký tự gạch dưới. Trình dịch cho phép sử dụng một số toán tử
khi dịch, nhờ đó chúng ta có thể viết các giá trị này theo cách dễ hiểu vào kiểm
tra hơn, thay vì viết 10,000. Xem phần <a href="../reference/const_eval.html">Rust Reference’s section on constant
evaluation</a> để biết thêm về những toán tử nào ta có thể dùng được
khi khai báo hằng.</p>
<p>Hằng có giá trị trong toàn bộ thời gian chương trình chạy, trong phạm vi chúng
được khai báo. Tính chất này làm cho các hằng trở nên hữu ích với những giá trị trong
miền ứng dụng mà nhiều phần khác của chương trình có thể cần biết tới, chẳng hạn
như số điểm tối đa mà mà một người chơi của trò chơi có thể kiếm được hoặc
tốc độ ánh sáng.</p>
<p>Đặt tên cho các giá trị được mã hóa cứng được sử dụng trong suốt chương trình của bạn
dưới dạng hằng rất hữu ích trong việc truyền đạt ý nghĩa của giá trị đó cho
những người duy trì code trong tương lai. Nó cũng giúp chỉ có một vị trí trong code
cần thay đổi nếu giá trị của hằng cần được cập nhật trong tương lai.</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>Như bạn đã thấy trong phần hướng dẫn trò chơi đoán số trong phần <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">Chapter
2</a><!-- ignore -->, bạn có thể khai báo một
biến mới trùng tên với biến trước đó. Rustaceans nói rằng biến đầu tiên bị
<em>shadowed</em> bởi biến thứ hai, nghĩa là trình biên dịch sẽ chỉ thấy biến thứ hai
khi bạn sử dụng tên của biến. Trên thực tế, biến thứ hai che đi biến thứ nhất,
sở hữu tên biến cho đến khi chính nó bị shadowed hoặc phạm vi kết thúc.
Chúng ta có thể shadow một biến bằng cách sử dụng tên của biến đó và lặp lại
sử dụng từ khóa <code>let</code> như sau:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>Đầu tiên chương trình này liên kết <code>x</code> với giá trị là<code> 5</code>. Sau đó, nó tạo ra một biến mới
<code>x</code> bằng cách lặp lại <code>let x = </code>, lấy giá trị ban đầu và thêm <code>1</code> để giá trị
của <code>x</code> khi đó là<code> 6</code>. Sau đó, trong một phạm vi mới được tạo bằng cặp dấu ngoặc kép,
câu lệnh thứ ba <code>let</code> cũng shadow <code>x</code> và tạo ra một biến mới, nhân giá trị trước đó
với <code>2</code> để cung cấp cho <code>x</code> giá trị là <code>12</code>.
Khi phạm vi đó kết thúc, việc shadow bên trong kết thúc và <code>x</code> trở lại là <code>6</code>.
Khi chúng ta chạy chương trình này, nó sẽ xuất ra như sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>Shadowing khác với việc đánh dấu một biến là <code>mut</code>, vì chúng ta sẽ nhận được một
lỗi thời gian biên dịch nếu chúng ta vô tình cố gắng gán lại biến này mà không
sử dụng từ khóa <code>let</code>. Bằng cách sử dụng <code>let</code>, chúng ta có thể thực hiện một
số phép biến đổi trên một biến nhưng biến đó lấy lại giá trị ban đầu sau khi hoàn thành công việc.</p>
<p>Sự khác biệt khác giữa <code>mut</code> và shadowing là khi ta tạo một biến mới bằng cách dùng từ khóa <code>let</code>,
chúng ta có thể thay đổi kiểu của biến nhưng sử dụng lại tên. Ví dụ, cho một chương trình
yêu cầu người dùng hiển thị bao nhiêu khoảng trắng họ muốn giữa một số văn bản bằng cách
nhập các ký tự khoảng trắng, sau đó lưu lại dữ liệu đó đó dưới dạng số:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>Biến <code>spaces</code> đầu tiên là một kiểu string và biến <code>spaces</code> thứ hai là kiểu số.
Shadowing do đó giúp chúng ta không phải nghĩ ra các tên khác nhau, chẳng hạn
như <code>spaces_str</code> và <code>spaces_num</code>; thay vào đó, chúng ta có thể sử dụng lại
tên <code>spaces</code> đơn giản hơn. Tuy nhiên, nếu chúng ta cố gắng sử dụng <code>mut</code> cho điều này,
như được hiển thị ở đây, chúng ta sẽ gặp lỗi biên dịch:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>Lỗi này nó là chúng ta không được phép thay đổi kiểu của một biến:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Chúng ta đã xem xong cách các biến làm việc, giờ hãy cùng xem các kiểu dữ liệu chúng có thể có.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-02-data-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-00-common-programming-concepts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-02-data-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
