<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Message Passing to Transfer Data Between Threads - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="sử-dụng-message-passing-để-chuyển-dữ-liệu-giữa-các-luồng"><a class="header" href="#sử-dụng-message-passing-để-chuyển-dữ-liệu-giữa-các-luồng">Sử dụng Message Passing để Chuyển Dữ liệu Giữa Các Luồng</a></h2>
<p>Một phương pháp ngày càng phổ biến để đảm bảo concurrency an toàn là <em>message passing</em>, nơi các luồng hoặc actor giao tiếp bằng cách gửi cho nhau các thông điệp chứa dữ liệu. Ý tưởng này được tóm tắt trong một câu slogan từ <a href="https://golang.org/doc/effective_go.html#concurrency">tài liệu ngôn ngữ Go</a>:
“Đừng giao tiếp bằng cách chia sẻ bộ nhớ; thay vào đó, hãy chia sẻ bộ nhớ bằng cách giao tiếp.”</p>
<p>Để thực hiện concurrency dựa trên gửi thông điệp, thư viện chuẩn của Rust cung cấp một triển khai của <em>channels</em>. Một channel là một khái niệm lập trình tổng quát, theo đó dữ liệu được gửi từ một luồng sang luồng khác.</p>
<p>Bạn có thể tưởng tượng một channel trong lập trình giống như một dòng nước có hướng, chẳng hạn như một con suối hoặc một dòng sông. Nếu bạn đặt một thứ gì đó như một con vịt cao su vào sông, nó sẽ trôi xuôi dòng đến cuối con đường nước.</p>
<p>Một channel có hai nửa: nửa truyền và nửa nhận. Nửa truyền là vị trí thượng lưu nơi bạn đặt các con vịt cao su vào sông, và nửa nhận là nơi con vịt cao su sẽ đến hạ lưu. Một phần mã của bạn gọi các phương thức trên nửa truyền với dữ liệu bạn muốn gửi, và phần khác kiểm tra đầu nhận để nhận các thông điệp đến. Một channel được coi là <em>đóng</em> nếu một trong hai nửa truyền hoặc nhận bị thả.</p>
<p>Ở đây, chúng ta sẽ phát triển một chương trình có một luồng tạo giá trị và gửi chúng xuống một channel, và một luồng khác sẽ nhận các giá trị đó và in ra. Chúng ta sẽ gửi các giá trị đơn giản giữa các luồng sử dụng channel để minh họa tính năng. Khi bạn đã quen với kỹ thuật này, bạn có thể sử dụng channels cho bất kỳ luồng nào cần giao tiếp với nhau, chẳng hạn như hệ thống chat hoặc một hệ thống nơi nhiều luồng thực hiện các phần của phép tính và gửi các phần đó đến một luồng tổng hợp kết quả.</p>
<p>Đầu tiên, trong Listing 16-6, chúng ta sẽ tạo một channel nhưng chưa làm gì với nó. Lưu ý rằng điều này sẽ chưa biên dịch vì Rust chưa biết loại giá trị nào chúng ta muốn gửi qua channel.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">Listing 16-6: Tạo một channel và gán hai nửa cho <code>tx</code> và <code>rx</code></span></p>
<p>Chúng ta tạo một channel mới bằng cách sử dụng hàm <code>mpsc::channel</code>; <code>mpsc</code> viết tắt của <em>multiple producer, single consumer</em> (nhiều người sản xuất, một người tiêu thụ). Tóm lại, cách thư viện chuẩn của Rust triển khai channels nghĩa là một channel có thể có nhiều <em>sending</em> ends tạo ra giá trị nhưng chỉ có một <em>receiving</em> end tiêu thụ các giá trị đó. Hãy tưởng tượng nhiều dòng suối hợp lại thành một dòng sông lớn: tất cả mọi thứ được gửi từ bất kỳ dòng suối nào sẽ kết thúc trong một dòng sông ở cuối. Hiện tại, chúng ta sẽ bắt đầu với một producer duy nhất, nhưng sau đó sẽ thêm nhiều producer khi ví dụ này hoạt động.</p>
<p>Hàm <code>mpsc::channel</code> trả về một tuple, phần tử đầu tiên là nửa gửi – transmitter – và phần tử thứ hai là nửa nhận – receiver. Các viết tắt <code>tx</code> và <code>rx</code> thường được sử dụng trong nhiều lĩnh vực cho <em>transmitter</em> và <em>receiver</em> tương ứng, vì vậy chúng ta đặt tên biến như vậy để chỉ định mỗi đầu. Chúng ta sử dụng một câu lệnh <code>let</code> với pattern để destructure tuple; chúng ta sẽ bàn về việc sử dụng pattern trong các câu lệnh <code>let</code> và destructuring trong Chương 18. Hiện tại, hãy biết rằng việc sử dụng câu lệnh <code>let</code> theo cách này là một cách tiện lợi để trích xuất các phần tử của tuple do <code>mpsc::channel</code> trả về.</p>
<p>Hãy di chuyển nửa truyền vào một luồng được spawn và cho nó gửi một chuỗi để luồng spawn có thể giao tiếp với luồng chính, như được hiển thị trong Listing 16-7. Điều này giống như đặt một con vịt cao su vào dòng sông thượng lưu hoặc gửi một tin nhắn chat từ một luồng sang luồng khác.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Listing 16-7: Di chuyển <code>tx</code> vào luồng spawn và gửi “hi”</span></p>
<p>Một lần nữa, chúng ta sử dụng <code>thread::spawn</code> để tạo một luồng mới và sau đó dùng <code>move</code> để di chuyển <code>tx</code> vào closure sao cho luồng spawn sở hữu <code>tx</code>. Luồng spawn cần sở hữu transmitter để có thể gửi tin nhắn qua channel. Transmitter có phương thức <code>send</code> nhận giá trị mà chúng ta muốn gửi. Phương thức <code>send</code> trả về kiểu <code>Result&lt;T, E&gt;</code>, vì vậy nếu receiver đã bị drop và không có nơi nào để gửi giá trị, thao tác gửi sẽ trả về lỗi. Trong ví dụ này, chúng ta gọi <code>unwrap</code> để panic nếu có lỗi. Nhưng trong một ứng dụng thực tế, chúng ta sẽ xử lý nó một cách thích hợp: quay lại Chương 9 để xem các chiến lược xử lý lỗi đúng cách.</p>
<p>Trong Listing 16-8, chúng ta sẽ lấy giá trị từ receiver trong luồng chính. Điều này giống như lấy con vịt cao su từ cuối dòng sông hoặc nhận một tin nhắn chat.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre></pre>
<p><span class="caption">Listing 16-8: Nhận giá trị “hi” trong luồng chính và in ra</span></p>
<p>Receiver có hai phương thức hữu ích: <code>recv</code> và <code>try_recv</code>. Chúng ta đang sử dụng <code>recv</code>, viết tắt của <em>receive</em>, phương thức này sẽ block luồng chính và chờ cho đến khi một giá trị được gửi xuống channel. Khi có giá trị được gửi, <code>recv</code> sẽ trả về giá trị đó dưới dạng <code>Result&lt;T, E&gt;</code>. Khi transmitter đóng, <code>recv</code> sẽ trả về lỗi để báo rằng không còn giá trị nào nữa.</p>
<p>Phương thức <code>try_recv</code> không block, mà thay vào đó sẽ trả về ngay lập tức một <code>Result&lt;T, E&gt;</code>: giá trị <code>Ok</code> chứa tin nhắn nếu có tin nhắn, và giá trị <code>Err</code> nếu lần này không có tin nhắn nào. Sử dụng <code>try_recv</code> hữu ích nếu luồng này còn công việc khác để làm trong khi chờ tin nhắn: chúng ta có thể viết một vòng lặp gọi <code>try_recv</code> theo thời gian, xử lý tin nhắn nếu có, và nếu không thì làm công việc khác một thời gian ngắn trước khi kiểm tra lại.</p>
<p>Chúng ta đã dùng <code>recv</code> trong ví dụ này cho đơn giản; luồng chính không còn công việc gì khác ngoài chờ tin nhắn, nên việc block luồng chính là hợp lý.</p>
<p>Khi chạy code trong Listing 16-8, chúng ta sẽ thấy giá trị được in ra từ luồng chính:</p>
<!-- Không trích xuất đầu ra vì các thay đổi với đầu ra này không đáng kể;
các thay đổi có khả năng do các luồng chạy khác nhau chứ không phải do compiler thay đổi -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<h3 id="kênh-và-việc-chuyển-giao-quyền-sở-hữu"><a class="header" href="#kênh-và-việc-chuyển-giao-quyền-sở-hữu">Kênh và Việc Chuyển Giao Quyền Sở Hữu</a></h3>
<p>Các quy tắc sở hữu đóng vai trò then chốt trong việc gửi tin nhắn
vì chúng giúp bạn viết mã đồng thời an toàn. Ngăn ngừa lỗi trong
lập trình đồng thời là lợi ích của việc luôn xem xét quyền sở hữu
trong toàn bộ chương trình Rust của bạn. Hãy làm một thí nghiệm để
minh họa cách kênh và quyền sở hữu phối hợp ngăn ngừa vấn đề: chúng ta
sẽ thử sử dụng một giá trị <code>val</code> trong luồng được tạo ra <em>sau khi</em> đã gửi nó qua kênh.
Hãy thử biên dịch mã trong Listing 16-9 để thấy tại sao mã này không được phép:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
<p><span class="caption">Listing 16-9: Thử sử dụng <code>val</code> sau khi chúng ta đã gửi nó
qua kênh</span></p>
<p>Ở đây, chúng ta cố gắng in ra <code>val</code> sau khi đã gửi nó xuống kênh thông qua
<code>tx.send</code>. Việc cho phép điều này sẽ là một ý tưởng tồi: một khi giá trị đã
được gửi sang một luồng khác, luồng đó có thể sửa đổi hoặc hủy (drop) nó trước
khi chúng ta cố gắng sử dụng lại giá trị này. Rất có thể, các thay đổi từ luồng
kia sẽ gây ra lỗi hoặc những kết quả không mong muốn do dữ liệu không nhất
quán hoặc thậm chí không còn tồn tại. Tuy nhiên, Rust sẽ báo lỗi khi chúng ta
cố gắng biên dịch mã trong Listing 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Lỗi đồng thời (concurrency) của chúng ta đã gây ra một lỗi tại thời điểm biên dịch. Hàm <code>send</code>
sẽ lấy quyền sở hữu (take ownership) của tham số truyền vào, và khi giá trị bị move, phía nhận
(receiver) sẽ nắm quyền sở hữu của nó. Điều này ngăn chúng ta vô tình sử dụng lại giá trị sau khi
đã gửi đi; hệ thống ownership sẽ kiểm tra để đảm bảo mọi thứ đều hợp lệ.</p>
<h3 id="gửi-nhiều-giá-trị-và-quan-sát-receiver-Đang-chờ"><a class="header" href="#gửi-nhiều-giá-trị-và-quan-sát-receiver-Đang-chờ">Gửi Nhiều Giá Trị và Quan Sát Receiver Đang Chờ</a></h3>
<p>Đoạn mã trong Listing 16-8 đã biên dịch và chạy được, nhưng nó chưa cho thấy rõ rằng
hai thread riêng biệt đang giao tiếp với nhau thông qua channel. Trong Listing
16-10, chúng ta đã thực hiện một số chỉnh sửa để chứng minh rằng đoạn mã trong
Listing 16-8 thực sự đang chạy đồng thời: thread được spawn giờ đây sẽ gửi nhiều
thông điệp và tạm dừng một giây giữa mỗi lần gửi.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
<p><span class="caption">Listing 16-10: Gửi nhiều thông điệp và tạm dừng
giữa mỗi lần gửi</span></p>
<p>Lần này, thread được spawn có một vector các chuỗi mà chúng ta muốn gửi tới
thread chính. Chúng ta lặp qua từng phần tử, gửi từng giá trị một, và tạm dừng
giữa mỗi lần gửi bằng cách gọi hàm <code>thread::sleep</code> với một giá trị <code>Duration</code>
là 1 giây.</p>
<p>Trong thread chính, chúng ta không còn gọi hàm <code>recv</code> một cách tường minh nữa:
thay vào đó, chúng ta coi <code>rx</code> như một iterator. Với mỗi giá trị nhận được,
chúng ta in nó ra. Khi channel bị đóng, quá trình lặp sẽ kết thúc.</p>
<p>Khi chạy đoạn mã trong Listing 16-10, bạn sẽ thấy output sau, với khoảng dừng
1 giây giữa mỗi dòng:</p>
<!-- Không trích xuất output vì những thay đổi trong output này không đáng kể;
các thay đổi nhiều khả năng là do các thread chạy khác nhau, thay vì do
những thay đổi trong trình biên dịch -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Bởi vì trong vòng lặp <code>for</code> ở thread chính chúng ta không có bất kỳ đoạn mã nào
để tạm dừng hay trì hoãn, nên có thể thấy rằng thread chính đang chờ để nhận
các giá trị được gửi từ thread được spawn.</p>
<h3 id="tạo-nhiều-producer-bằng-cách-clone-transmitter"><a class="header" href="#tạo-nhiều-producer-bằng-cách-clone-transmitter">Tạo Nhiều Producer bằng Cách Clone Transmitter</a></h3>
<p>Trước đó, chúng ta đã đề cập rằng <code>mpsc</code> là từ viết tắt của <em>multiple producer,
single consumer</em> (nhiều bên gửi, một bên nhận). Bây giờ hãy áp dụng <code>mpsc</code> và
mở rộng đoạn mã trong Listing 16-10 để tạo ra nhiều thread, tất cả đều gửi giá
trị tới cùng một receiver. Chúng ta có thể làm điều này bằng cách clone
transmitter, như được minh họa trong Listing 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 16-11: Gửi nhiều thông điệp từ nhiều producer</span></p>
<p>Lần này, trước khi tạo thread được spawn đầu tiên, chúng ta gọi <code>clone</code> trên
transmitter. Việc này sẽ tạo ra một transmitter mới để chúng ta truyền vào
thread được spawn thứ nhất. Transmitter gốc sẽ được truyền cho thread được spawn
thứ hai. Kết quả là chúng ta có hai thread, mỗi thread gửi các thông điệp khác
nhau tới cùng một receiver.</p>
<p>Khi bạn chạy đoạn mã, output sẽ trông tương tự như sau:</p>
<!-- Không trích xuất output vì những thay đổi trong output này không đáng kể;
các thay đổi nhiều khả năng là do các thread chạy khác nhau, thay vì do
những thay đổi trong trình biên dịch -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Bạn có thể sẽ thấy các giá trị xuất hiện theo một thứ tự khác, tùy thuộc vào hệ
thống của bạn. Đây chính là điều khiến concurrency vừa thú vị vừa khó khăn. Nếu
bạn thử nghiệm với <code>thread::sleep</code>, truyền cho nó các giá trị khác nhau ở các
thread khác nhau, thì mỗi lần chạy chương trình sẽ càng trở nên không xác định
(nondeterministic) hơn và tạo ra output khác nhau mỗi lần.</p>
<p>Bây giờ, sau khi đã xem cách các channel hoạt động, chúng ta hãy cùng xem một
phương pháp concurrency khác.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-01-threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-03-shared-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-01-threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-03-shared-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
