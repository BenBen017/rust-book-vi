<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt; and the Interior Mutability Pattern - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt-và-mẫu-interior-mutability"><a class="header" href="#refcellt-và-mẫu-interior-mutability"><code>RefCell&lt;T&gt;</code> và Mẫu Interior Mutability</a></h2>
<p><em>Interior mutability</em> là một mẫu thiết kế trong Rust cho phép bạn thay đổi dữ liệu ngay cả khi có các tham chiếu không thay đổi đến dữ liệu đó; thông thường, hành động này bị cấm bởi các quy tắc mượn. Để thay đổi dữ liệu, mẫu này sử dụng mã <code>unsafe</code> bên trong một cấu trúc dữ liệu để uốn nắn các quy tắc thông thường của Rust về mutation và borrowing. Mã <code>unsafe</code> báo cho trình biên dịch rằng chúng ta sẽ kiểm tra các quy tắc thủ công thay vì dựa vào trình biên dịch; chúng ta sẽ thảo luận thêm về mã <code>unsafe</code> trong Chương 19.</p>
<p>Chúng ta chỉ có thể sử dụng các kiểu dữ liệu áp dụng mẫu interior mutability khi có thể đảm bảo rằng các quy tắc mượn sẽ được tuân thủ tại thời điểm chạy, mặc dù trình biên dịch không thể đảm bảo điều đó. Mã <code>unsafe</code> liên quan sẽ được bao bọc trong một API an toàn, và kiểu bên ngoài vẫn không thay đổi.</p>
<p>Hãy khám phá khái niệm này bằng cách xem kiểu <code>RefCell&lt;T&gt;</code> áp dụng mẫu interior mutability.</p>
<h3 id="thực-thi-các-quy-tắc-mượn-tại-thời-điểm-chạy-với-refcellt"><a class="header" href="#thực-thi-các-quy-tắc-mượn-tại-thời-điểm-chạy-với-refcellt">Thực thi các quy tắc mượn tại thời điểm chạy với <code>RefCell&lt;T&gt;</code></a></h3>
<p>Khác với <code>Rc&lt;T&gt;</code>, kiểu <code>RefCell&lt;T&gt;</code> đại diện cho quyền sở hữu duy nhất đối với dữ liệu mà nó giữ. Vậy điều gì làm <code>RefCell&lt;T&gt;</code> khác với một kiểu như <code>Box&lt;T&gt;</code>? Hãy nhớ lại các quy tắc mượn mà bạn đã học trong Chương 4:</p>
<ul>
<li>Tại bất kỳ thời điểm nào, bạn có thể có <em>hoặc</em> (nhưng không phải cả hai) một tham chiếu có thể thay đổi hoặc bất kỳ số lượng tham chiếu không thay đổi nào.</li>
<li>Các tham chiếu phải luôn hợp lệ.</li>
</ul>
<p>Với các tham chiếu và <code>Box&lt;T&gt;</code>, các quy tắc mượn được thực thi tại thời điểm biên dịch. Với <code>RefCell&lt;T&gt;</code>, những bất biến này được thực thi <em>tại thời điểm chạy</em>. Với các tham chiếu, nếu bạn vi phạm các quy tắc này, bạn sẽ nhận được lỗi biên dịch. Với <code>RefCell&lt;T&gt;</code>, nếu bạn vi phạm các quy tắc này, chương trình của bạn sẽ panic và kết thúc.</p>
<p>Ưu điểm của việc kiểm tra các quy tắc mượn tại thời điểm biên dịch là các lỗi sẽ được phát hiện sớm hơn trong quá trình phát triển, và không ảnh hưởng đến hiệu năng tại thời điểm chạy vì tất cả phân tích đã hoàn tất trước đó. Vì những lý do này, kiểm tra các quy tắc mượn tại thời điểm biên dịch là lựa chọn tốt nhất trong hầu hết các trường hợp, đó là lý do tại sao đây là mặc định của Rust.</p>
<p>Ưu điểm của việc kiểm tra các quy tắc mượn tại thời điểm chạy là cho phép một số tình huống an toàn về bộ nhớ mà nếu kiểm tra tại thời điểm biên dịch sẽ bị cấm. Phân tích tĩnh, như trình biên dịch Rust, vốn mang tính thận trọng. Một số đặc tính của mã là không thể phát hiện bằng việc phân tích mã: ví dụ nổi tiếng nhất là Vấn đề Halting, vượt ngoài phạm vi cuốn sách này nhưng là một chủ đề thú vị để nghiên cứu.</p>
<p>Bởi vì một số phân tích là không thể, nếu trình biên dịch Rust không chắc chắn mã tuân thủ các quy tắc sở hữu, nó có thể từ chối một chương trình hợp lệ; theo cách này, nó mang tính thận trọng. Nếu Rust chấp nhận một chương trình không đúng, người dùng sẽ không thể tin tưởng vào các đảm bảo mà Rust đưa ra. Tuy nhiên, nếu Rust từ chối một chương trình hợp lệ, lập trình viên sẽ gặp bất tiện, nhưng không có gì thảm khốc xảy ra. Kiểu <code>RefCell&lt;T&gt;</code> hữu ích khi bạn chắc chắn mã của mình tuân thủ các quy tắc mượn nhưng trình biên dịch không thể hiểu và đảm bảo điều đó.</p>
<p>Tương tự như <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> chỉ dùng trong các kịch bản đơn luồng và sẽ báo lỗi biên dịch nếu bạn cố gắng sử dụng trong bối cảnh đa luồng. Chúng ta sẽ nói về cách có được chức năng của <code>RefCell&lt;T&gt;</code> trong chương trình đa luồng ở Chương 16.</p>
<p>Dưới đây là tóm tắt lý do chọn <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> hoặc <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> cho phép nhiều chủ sở hữu cùng dữ liệu; <code>Box&lt;T&gt;</code> và <code>RefCell&lt;T&gt;</code> chỉ có một chủ sở hữu.</li>
<li><code>Box&lt;T&gt;</code> cho phép mượn có thể hoặc không thể thay đổi được kiểm tra tại thời điểm biên dịch; <code>Rc&lt;T&gt;</code> chỉ cho phép mượn không thay đổi được kiểm tra tại thời điểm biên dịch; <code>RefCell&lt;T&gt;</code> cho phép mượn có thể hoặc không thể thay đổi được kiểm tra tại thời điểm chạy.</li>
<li>Vì <code>RefCell&lt;T&gt;</code> cho phép mượn có thể thay đổi được kiểm tra tại thời điểm chạy, bạn có thể thay đổi giá trị bên trong <code>RefCell&lt;T&gt;</code> ngay cả khi <code>RefCell&lt;T&gt;</code> là bất biến.</li>
</ul>
<p>Việc thay đổi giá trị bên trong một giá trị bất biến là mẫu <em>interior mutability</em>. Hãy xem xét một tình huống mà interior mutability hữu ích và khám phá cách mà nó có thể thực hiện được.</p>
<h3 id="interior-mutability-mượn-có-thể-thay-đổi-trên-một-giá-trị-bất-biến"><a class="header" href="#interior-mutability-mượn-có-thể-thay-đổi-trên-một-giá-trị-bất-biến">Interior Mutability: Mượn có thể thay đổi trên một giá trị bất biến</a></h3>
<p>Một hệ quả của các quy tắc mượn là khi bạn có một giá trị bất biến, bạn không thể mượn nó theo cách có thể thay đổi. Ví dụ, đoạn mã này sẽ không biên dịch:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>Nếu bạn thử biên dịch đoạn mã này, bạn sẽ nhận được lỗi sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>Tuy nhiên, có những tình huống mà một giá trị có thể tự thay đổi trong
các phương thức của nó nhưng vẫn xuất hiện như bất biến đối với các đoạn mã khác.
Các đoạn mã bên ngoài các phương thức của giá trị sẽ không thể thay đổi giá trị đó.
Sử dụng <code>RefCell&lt;T&gt;</code> là một cách để có thể thực hiện <em>interior mutability</em>,
nhưng <code>RefCell&lt;T&gt;</code> không bỏ qua hoàn toàn các quy tắc mượn: trình kiểm tra mượn
trong trình biên dịch cho phép nội bộ thay đổi này và các quy tắc mượn được kiểm tra tại thời gian chạy.
Nếu bạn vi phạm các quy tắc này, bạn sẽ nhận được một <code>panic!</code> thay vì lỗi biên dịch.</p>
<p>Hãy cùng xem một ví dụ thực tế nơi chúng ta có thể sử dụng <code>RefCell&lt;T&gt;</code> để thay đổi
một giá trị bất biến và hiểu tại sao điều đó lại hữu ích.</p>
<h4 id="trường-hợp-sử-dụng-interior-mutability-mock-objects"><a class="header" href="#trường-hợp-sử-dụng-interior-mutability-mock-objects">Trường hợp sử dụng Interior Mutability: Mock Objects</a></h4>
<p>Đôi khi trong quá trình kiểm thử, lập trình viên sẽ sử dụng một kiểu thay cho một
kiểu khác để quan sát hành vi cụ thể và xác nhận rằng nó được thực hiện đúng.
Kiểu thay thế này được gọi là <em>test double</em>. Hãy tưởng tượng nó giống như một “stunt double” trong điện ảnh,
nơi một người đóng thế cho diễn viên trong một cảnh khó. Test doubles đứng thay cho
các kiểu khác khi chúng ta chạy kiểm thử. <em>Mock objects</em> là những loại test doubles
cụ thể ghi lại những gì xảy ra trong quá trình kiểm thử để bạn có thể xác nhận rằng các hành động đúng đã diễn ra.</p>
<p>Rust không có các object theo cùng cách các ngôn ngữ khác có object,
và Rust không có chức năng mock object tích hợp trong thư viện chuẩn như một số ngôn ngữ khác.
Tuy nhiên, bạn hoàn toàn có thể tạo một struct phục vụ cùng mục đích như một mock object.</p>
<p>Dưới đây là kịch bản mà chúng ta sẽ kiểm thử: chúng ta sẽ tạo một thư viện theo dõi
giá trị so với giá trị tối đa và gửi thông điệp dựa trên mức gần với giá trị tối đa
mà giá trị hiện tại đạt được. Thư viện này có thể được dùng để theo dõi hạn mức API mà người dùng được phép gọi, ví dụ.</p>
<p>Thư viện của chúng ta chỉ cung cấp chức năng theo dõi mức gần với giá trị
tối đa và các thông điệp nên được gửi khi nào. Ứng dụng sử dụng thư viện này
sẽ chịu trách nhiệm cung cấp cơ chế gửi thông điệp: ứng dụng có thể lưu thông điệp,
gửi email, gửi tin nhắn, hoặc thực hiện việc khác. Thư viện không cần biết chi tiết đó.
Tất cả những gì nó cần là một thứ gì đó thực thi một trait mà chúng ta sẽ cung cấp gọi là <code>Messenger</code>.
Listing 15-20 hiển thị mã thư viện:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<p><span class="caption">Listing 15-20: Một thư viện để theo dõi mức gần với giá trị tối đa và cảnh báo khi giá trị đạt các mức nhất định</span></p>
<p>Một phần quan trọng của mã này là trait <code>Messenger</code> có một phương thức gọi là <code>send</code> nhận một tham chiếu bất biến tới <code>self</code> và nội dung của thông điệp. Trait này là giao diện mà mock object của chúng ta cần thực thi để mock có thể được sử dụng giống như một object thật. Phần quan trọng khác là chúng ta muốn kiểm thử hành vi của phương thức <code>set_value</code> trên <code>LimitTracker</code>. Chúng ta có thể thay đổi giá trị truyền vào tham số <code>value</code>, nhưng <code>set_value</code> không trả về gì để chúng ta thực hiện các khẳng định. Chúng ta muốn có thể nói rằng nếu chúng ta tạo một <code>LimitTracker</code> với một thứ thực thi trait <code>Messenger</code> và một giá trị cụ thể cho <code>max</code>, khi truyền các số khác nhau cho <code>value</code>, messenger sẽ được yêu cầu gửi các thông điệp thích hợp.</p>
<p>Chúng ta cần một mock object mà thay vì gửi email hoặc tin nhắn khi gọi <code>send</code>, chỉ giữ lại các thông điệp mà nó được yêu cầu gửi. Chúng ta có thể tạo một instance mới của mock object, tạo một <code>LimitTracker</code> sử dụng mock object đó, gọi phương thức <code>set_value</code> trên <code>LimitTracker</code>, và sau đó kiểm tra xem mock object có các thông điệp mà chúng ta mong đợi không. Listing 15-21 trình bày một thử nghiệm triển khai mock object làm việc này, nhưng trình kiểm tra mượn sẽ không cho phép:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<p><span class="caption">Listing 15-21: Một nỗ lực triển khai <code>MockMessenger</code> nhưng không được trình kiểm tra mượn cho phép</span></p>
<p>Mã kiểm thử này định nghĩa một struct <code>MockMessenger</code> có trường <code>sent_messages</code> với một <code>Vec</code> chứa các giá trị <code>String</code> để theo dõi các thông điệp mà nó được yêu cầu gửi. Chúng ta cũng định nghĩa một hàm liên kết <code>new</code> để thuận tiện tạo các giá trị <code>MockMessenger</code> mới bắt đầu với danh sách thông điệp trống. Sau đó, chúng ta triển khai trait <code>Messenger</code> cho <code>MockMessenger</code> để có thể cung cấp một <code>MockMessenger</code> cho <code>LimitTracker</code>. Trong định nghĩa phương thức <code>send</code>, chúng ta lấy thông điệp truyền vào dưới dạng tham số và lưu nó vào danh sách <code>sent_messages</code> của <code>MockMessenger</code>.</p>
<p>Trong kiểm thử, chúng ta kiểm tra điều gì xảy ra khi <code>LimitTracker</code> được yêu cầu đặt <code>value</code> thành một giá trị lớn hơn 75% giá trị <code>max</code>. Trước tiên, chúng ta tạo một <code>MockMessenger</code> mới, bắt đầu với danh sách thông điệp trống. Sau đó, chúng ta tạo một <code>LimitTracker</code> mới và truyền cho nó một tham chiếu tới <code>MockMessenger</code> mới và một giá trị <code>max</code> bằng 100. Chúng ta gọi phương thức <code>set_value</code> trên <code>LimitTracker</code> với giá trị 80, lớn hơn 75% của 100. Sau đó, chúng ta khẳng định rằng danh sách thông điệp mà <code>MockMessenger</code> theo dõi bây giờ phải có một thông điệp.</p>
<p>Tuy nhiên, có một vấn đề với kiểm thử này, như được trình bày ở đây:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>Chúng ta không thể sửa <code>MockMessenger</code> để theo dõi các thông điệp, vì phương thức <code>send</code> nhận một tham chiếu không thay đổi tới <code>self</code>. Chúng ta cũng không thể áp dụng gợi ý từ thông báo lỗi để dùng <code>&amp;mut self</code>, vì khi đó chữ ký của <code>send</code> sẽ không khớp với chữ ký trong định nghĩa trait <code>Messenger</code> (bạn có thể thử và xem thông báo lỗi nhận được).</p>
<p>Đây là một tình huống mà <em>interior mutability</em> có thể giúp ích! Chúng ta sẽ lưu <code>sent_messages</code> bên trong một <code>RefCell&lt;T&gt;</code>, và sau đó phương thức <code>send</code> sẽ có thể sửa đổi <code>sent_messages</code> để lưu các thông điệp mà chúng ta đã nhận thấy. Listing 15-22 minh họa điều đó:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">Listing 15-22: Sử dụng <code>RefCell&lt;T&gt;</code> để thay đổi giá trị bên trong trong khi giá trị bên ngoài được coi là bất biến</span></p>
<p>Trường <code>sent_messages</code> bây giờ có kiểu <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> thay vì <code>Vec&lt;String&gt;</code>. Trong hàm <code>new</code>, chúng ta tạo một thể hiện <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> xung quanh vector rỗng.</p>
<p>Trong phần triển khai phương thức <code>send</code>, tham số đầu tiên vẫn là một borrow bất biến của <code>self</code>, khớp với định nghĩa trait. Chúng ta gọi <code>borrow_mut</code> trên <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> trong <code>self.sent_messages</code> để lấy một tham chiếu mutable tới giá trị bên trong <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, chính là vector. Sau đó, chúng ta có thể gọi <code>push</code> trên tham chiếu mutable của vector để lưu lại các thông điệp được gửi trong quá trình test.</p>
<p>Thay đổi cuối cùng là trong assertion: để xem có bao nhiêu mục trong vector bên trong, chúng ta gọi <code>borrow</code> trên <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> để lấy một tham chiếu bất biến tới vector.</p>
<p>Bây giờ bạn đã thấy cách sử dụng <code>RefCell&lt;T&gt;</code>, hãy tìm hiểu cách nó hoạt động!</p>
<h4 id="theo-dõi-borrow-tại-runtime-với-refcellt"><a class="header" href="#theo-dõi-borrow-tại-runtime-với-refcellt">Theo dõi borrow tại runtime với <code>RefCell&lt;T&gt;</code></a></h4>
<p>Khi tạo các tham chiếu bất biến và mutable, chúng ta dùng cú pháp <code>&amp;</code> và <code>&amp;mut</code>. Với <code>RefCell&lt;T&gt;</code>, chúng ta dùng các phương thức <code>borrow</code> và <code>borrow_mut</code>, là một phần của API an toàn thuộc về <code>RefCell&lt;T&gt;</code>. Phương thức <code>borrow</code> trả về smart pointer kiểu <code>Ref&lt;T&gt;</code>, và <code>borrow_mut</code> trả về smart pointer kiểu <code>RefMut&lt;T&gt;</code>. Cả hai kiểu đều implement <code>Deref</code>, vì vậy chúng ta có thể sử dụng chúng như các tham chiếu thông thường.</p>
<p><code>RefCell&lt;T&gt;</code> theo dõi có bao nhiêu smart pointer <code>Ref&lt;T&gt;</code> và <code>RefMut&lt;T&gt;</code> đang hoạt động. Mỗi lần gọi <code>borrow</code>, <code>RefCell&lt;T&gt;</code> tăng số lượng immutable borrows đang hoạt động. Khi một giá trị <code>Ref&lt;T&gt;</code> ra khỏi scope, số lượng immutable borrows giảm đi một. Giống như các quy tắc borrow tại compile-time, <code>RefCell&lt;T&gt;</code> cho phép nhiều immutable borrows hoặc một mutable borrow tại bất kỳ thời điểm nào.</p>
<p>Nếu chúng ta cố vi phạm các quy tắc này, thay vì nhận lỗi biên dịch như với references, việc implement của <code>RefCell&lt;T&gt;</code> sẽ gây panic tại runtime. Listing 15-23 minh họa một sửa đổi của phương thức <code>send</code> trong Listing 15-22, chúng ta cố tình tạo hai mutable borrows cùng lúc để chứng minh rằng <code>RefCell&lt;T&gt;</code> ngăn chặn điều này tại runtime.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 15-23: Tạo hai tham chiếu mutable trong cùng một scope để thấy rằng <code>RefCell&lt;T&gt;</code> sẽ panic</span></p>
<p>Chúng ta tạo một biến <code>one_borrow</code> cho smart pointer <code>RefMut&lt;T&gt;</code> được trả về từ <code>borrow_mut</code>.
Sau đó, chúng ta tạo một borrow mutable khác theo cách tương tự trong biến <code>two_borrow</code>.
Điều này tạo ra hai tham chiếu mutable trong cùng một scope, điều mà không được phép.
Khi chạy các test cho thư viện của chúng ta, mã trong Listing 15-23 sẽ biên dịch mà không gặp lỗi, nhưng test sẽ thất bại:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Lưu ý rằng mã đã panic với thông báo <code>already borrowed: BorrowMutError</code>. Đây là cách mà <code>RefCell&lt;T&gt;</code> xử lý việc vi phạm các quy tắc mượn (borrowing rules) tại thời điểm chạy.</p>
<p>Việc chọn kiểm tra lỗi mượn tại thời điểm chạy thay vì thời điểm biên dịch, như chúng ta đã làm ở đây, có nghĩa là bạn có thể sẽ phát hiện ra lỗi trong mã muộn hơn trong quá trình phát triển: có thể là cho đến khi mã của bạn được triển khai vào môi trường sản xuất. Ngoài ra, mã của bạn sẽ chịu một chút chi phí hiệu năng tại thời điểm chạy do phải theo dõi các lần mượn tại runtime thay vì compile time. Tuy nhiên, việc sử dụng <code>RefCell&lt;T&gt;</code> cho phép bạn viết một đối tượng mock có thể tự sửa đổi để theo dõi các thông điệp mà nó đã nhận trong khi bạn đang sử dụng nó trong một ngữ cảnh mà chỉ cho phép các giá trị bất biến (immutable). Bạn có thể sử dụng <code>RefCell&lt;T&gt;</code> bất chấp những đánh đổi này để có thêm chức năng hơn so với các tham chiếu thông thường.</p>
<h3 id="sở-hữu-nhiều-chủ-sở-hữu-cho-dữ-liệu-có-thể-thay-đổi-bằng-cách-kết-hợp-rct-và-refcellt"><a class="header" href="#sở-hữu-nhiều-chủ-sở-hữu-cho-dữ-liệu-có-thể-thay-đổi-bằng-cách-kết-hợp-rct-và-refcellt">Sở hữu nhiều chủ sở hữu cho dữ liệu có thể thay đổi bằng cách kết hợp <code>Rc&lt;T&gt;</code> và <code>RefCell&lt;T&gt;</code></a></h3>
<p>Một cách phổ biến để sử dụng <code>RefCell&lt;T&gt;</code> là kết hợp với <code>Rc&lt;T&gt;</code>. Nhớ rằng <code>Rc&lt;T&gt;</code> cho phép bạn có nhiều chủ sở hữu cho cùng một dữ liệu, nhưng nó chỉ cung cấp quyền truy cập bất biến (immutable) tới dữ liệu đó. Nếu bạn có một <code>Rc&lt;T&gt;</code> chứa <code>RefCell&lt;T&gt;</code>, bạn sẽ có một giá trị vừa có thể có nhiều chủ sở hữu <em>vừa</em> có thể thay đổi được!</p>
<p>Ví dụ, hãy nhớ ví dụ danh sách cons trong Listing 15-18, nơi chúng ta sử dụng <code>Rc&lt;T&gt;</code> để cho phép nhiều danh sách chia sẻ quyền sở hữu của một danh sách khác. Vì <code>Rc&lt;T&gt;</code> chỉ chứa các giá trị bất biến, chúng ta không thể thay đổi bất kỳ giá trị nào trong danh sách sau khi đã tạo chúng. Hãy thêm <code>RefCell&lt;T&gt;</code> để có khả năng thay đổi các giá trị trong danh sách. Listing 15-24 cho thấy rằng bằng cách sử dụng <code>RefCell&lt;T&gt;</code> trong định nghĩa <code>Cons</code>, chúng ta có thể sửa đổi giá trị được lưu trữ trong tất cả các danh sách:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
<p><span class="caption">Listing 15-24: Sử dụng <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> để tạo một
<code>List</code> mà chúng ta có thể thay đổi</span></p>
<p>Chúng ta tạo một giá trị là một thể hiện của <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> và lưu nó
vào biến tên là <code>value</code> để sau này có thể truy cập trực tiếp. Sau đó chúng
ta tạo một <code>List</code> trong <code>a</code> với biến thể <code>Cons</code> chứa <code>value</code>. Chúng ta cần
clone <code>value</code> để cả <code>a</code> và <code>value</code> đều sở hữu giá trị bên trong là <code>5</code>, thay
vì chuyển quyền sở hữu từ <code>value</code> sang <code>a</code> hoặc để <code>a</code> mượn từ <code>value</code>.</p>
<p>Chúng ta bao <code>List</code> <code>a</code> trong một <code>Rc&lt;T&gt;</code> để khi tạo các danh sách <code>b</code> và <code>c</code>,
cả hai đều có thể tham chiếu tới <code>a</code>, giống như những gì chúng ta đã làm
trong Listing 15-18.</p>
<p>Sau khi tạo các danh sách <code>a</code>, <code>b</code>, và <code>c</code>, chúng ta muốn cộng thêm 10
vào giá trị trong <code>value</code>. Chúng ta làm điều này bằng cách gọi <code>borrow_mut</code>
trên <code>value</code>, sử dụng tính năng dereferencing tự động mà chúng ta đã thảo
luận trong Chương 5 (xem phần <a href="ch05-03-method-syntax.html#wheres-the---operator">“Where’s the <code>-&gt;</code> Operator?”</a><!-- ignore -->)
để giải tham chiếu <code>Rc&lt;T&gt;</code> tới giá trị bên trong <code>RefCell&lt;T&gt;</code>. Phương thức
<code>borrow_mut</code> trả về một con trỏ thông minh <code>RefMut&lt;T&gt;</code>, và chúng ta sử dụng
toán tử dereference trên nó và thay đổi giá trị bên trong.</p>
<p>Khi in <code>a</code>, <code>b</code>, và <code>c</code>, chúng ta có thể thấy rằng tất cả đều có giá trị
đã được sửa thành 15 thay vì 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Kỹ thuật này khá hay ho! Bằng cách sử dụng <code>RefCell&lt;T&gt;</code>, chúng ta có một
giá trị <code>List</code> bên ngoài là bất biến. Nhưng chúng ta có thể dùng các phương
thức trên <code>RefCell&lt;T&gt;</code> cung cấp quyền truy cập vào khả năng thay đổi bên trong
nó để sửa đổi dữ liệu khi cần. Các kiểm tra tại thời gian chạy về các quy
tắc mượn bảo vệ chúng ta khỏi các race condition, và đôi khi đáng để đánh
đổi một chút tốc độ để có sự linh hoạt này trong cấu trúc dữ liệu. Lưu ý
rằng <code>RefCell&lt;T&gt;</code> không hoạt động cho mã đa luồng! <code>Mutex&lt;T&gt;</code> là phiên bản
an toàn cho luồng của <code>RefCell&lt;T&gt;</code> và chúng ta sẽ thảo luận về <code>Mutex&lt;T&gt;</code>
trong Chương 16.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
