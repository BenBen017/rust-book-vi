<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Working with Environment Variables - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="làm-việc-với-biến-môi-trường"><a class="header" href="#làm-việc-với-biến-môi-trường">Làm việc với Biến Môi Trường</a></h2>
<p>Chúng ta sẽ cải tiến <code>minigrep</code> bằng cách thêm một tính năng: tùy chọn tìm kiếm không phân biệt chữ hoa chữ thường, mà người dùng có thể bật thông qua biến môi trường. Chúng ta có thể biến tính năng này thành một tùy chọn dòng lệnh và yêu cầu người dùng nhập nó mỗi lần muốn sử dụng, nhưng bằng cách dùng biến môi trường, chúng ta cho phép người dùng thiết lập một lần và tất cả các tìm kiếm sau đó trong phiên terminal đó sẽ không phân biệt chữ hoa chữ thường.</p>
<h3 id="viết-test-thất-bại-cho-hàm-search-không-phân-biệt-chữ-hoa"><a class="header" href="#viết-test-thất-bại-cho-hàm-search-không-phân-biệt-chữ-hoa">Viết Test Thất Bại cho Hàm <code>search</code> Không Phân Biệt Chữ Hoa</a></h3>
<p>Trước tiên, chúng ta thêm một hàm mới <code>search_case_insensitive</code> sẽ được gọi khi biến môi trường có giá trị. Chúng ta sẽ tiếp tục theo quy trình TDD, vì vậy bước đầu tiên là viết một test thất bại. Chúng ta sẽ thêm một test mới cho hàm <code>search_case_insensitive</code> và đổi tên test cũ từ <code>one_result</code> thành <code>case_sensitive</code> để làm rõ sự khác biệt giữa hai test, như minh họa trong Listing 12-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Listing 12-20: Thêm một test thất bại mới cho
hàm không phân biệt chữ hoa/chữ thường mà chúng ta sắp thêm</span></p>
<p>Lưu ý rằng chúng ta cũng đã chỉnh sửa <code>contents</code> của test cũ. Chúng ta đã thêm một dòng mới với nội dung <code>"Duct tape."</code> sử dụng chữ D viết hoa, dòng này không nên khớp với query <code>"duct"</code> khi chúng ta tìm kiếm theo kiểu phân biệt chữ hoa/chữ thường. Việc thay đổi test cũ theo cách này giúp đảm bảo rằng chúng ta không vô tình phá vỡ chức năng tìm kiếm phân biệt chữ hoa/chữ thường mà chúng ta đã triển khai. Test này nên chạy được và sẽ tiếp tục chạy khi chúng ta làm việc trên chức năng tìm kiếm không phân biệt chữ hoa/chữ thường.</p>
<p>Test mới cho tìm kiếm không phân biệt chữ hoa/chữ thường sử dụng <code>"rUsT"</code> làm query. Trong hàm <code>search_case_insensitive</code> mà chúng ta sắp thêm, query <code>"rUsT"</code> sẽ khớp với dòng chứa <code>"Rust:"</code> với chữ R viết hoa và cũng khớp với dòng <code>"Trust me."</code> mặc dù cả hai có cách viết khác với query. Đây là test thất bại của chúng ta, và nó sẽ không biên dịch được vì chúng ta chưa định nghĩa hàm <code>search_case_insensitive</code>. Bạn có thể thêm một triển khai skeleton trả về luôn một vector rỗng, tương tự như cách chúng ta làm với hàm <code>search</code> trong Listing 12-16 để thấy test biên dịch và thất bại.</p>
<h3 id="triển-khai-hàm-search_case_insensitive"><a class="header" href="#triển-khai-hàm-search_case_insensitive">Triển khai hàm <code>search_case_insensitive</code></a></h3>
<p>Hàm <code>search_case_insensitive</code>, như minh họa trong Listing 12-21, sẽ gần như giống hệt hàm <code>search</code>. Điểm khác duy nhất là chúng ta sẽ chuyển <code>query</code> và từng <code>line</code> về chữ thường, để dù đầu vào có kiểu chữ nào, chúng cũng sẽ cùng kiểu chữ khi kiểm tra xem dòng có chứa query hay không.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-21: Định nghĩa hàm <code>search_case_insensitive</code>
để chuyển query và dòng về chữ thường trước khi so sánh</span></p>
<p>Trước tiên, chúng ta chuyển chuỗi <code>query</code> về chữ thường và lưu vào một biến
shadow cùng tên. Việc gọi <code>to_lowercase</code> trên query là cần thiết để dù query
của người dùng là <code>"rust"</code>, <code>"RUST"</code>, <code>"Rust"</code>, hay <code>"rUsT"</code>, chúng ta sẽ
xử lý query như thể nó là <code>"rust"</code> và không phân biệt chữ hoa/chữ thường.
Mặc dù <code>to_lowercase</code> sẽ xử lý Unicode cơ bản, nhưng không hoàn toàn chính
xác 100%. Nếu chúng ta viết một ứng dụng thực sự, sẽ cần xử lý kỹ hơn ở
phần này, nhưng mục tiêu của phần này là biến môi trường, không phải Unicode,
nên chúng ta sẽ tạm dừng ở đây.</p>
<p>Lưu ý rằng <code>query</code> bây giờ là một <code>String</code> thay vì một slice của chuỗi, vì
việc gọi <code>to_lowercase</code> tạo ra dữ liệu mới thay vì tham chiếu dữ liệu có sẵn.
Ví dụ, nếu query là <code>"rUsT"</code>, slice này không chứa chữ <code>u</code> hay <code>t</code> viết
thường để chúng ta sử dụng, nên chúng ta phải cấp phát một <code>String</code> mới
chứa <code>"rust"</code>. Khi truyền <code>query</code> làm đối số cho phương thức <code>contains</code>, chúng
ta cần thêm dấu &amp; vì chữ ký của <code>contains</code> được định nghĩa để nhận một slice
của chuỗi.</p>
<p>Tiếp theo, chúng ta gọi <code>to_lowercase</code> trên từng <code>line</code> để chuyển tất cả
ký tự về chữ thường. Giờ đây, khi <code>line</code> và <code>query</code> đã được chuyển về chữ
thường, chúng ta sẽ tìm thấy các dòng khớp bất kể query có chữ hoa hay
chữ thường.</p>
<p>Hãy xem liệu triển khai này có vượt qua các test không:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Tuyệt vời! Các test đã vượt qua. Bây giờ, chúng ta sẽ gọi hàm mới
<code>search_case_insensitive</code> từ hàm <code>run</code>. Trước tiên, chúng ta sẽ thêm một
tùy chọn cấu hình vào struct <code>Config</code> để chuyển đổi giữa tìm kiếm phân biệt
chữ hoa/chữ thường và không phân biệt chữ hoa/chữ thường. Việc thêm trường
này sẽ gây ra lỗi biên dịch vì chúng ta chưa khởi tạo trường này ở đâu cả:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Chúng ta đã thêm trường <code>ignore_case</code> mà chứa một Boolean. Tiếp theo, chúng ta cần hàm <code>run</code>
để kiểm tra giá trị của trường <code>ignore_case</code> và dùng nó để quyết định
có gọi hàm <code>search</code> hay hàm <code>search_case_insensitive</code>
như được hiển thị trong Listing 12-22. Điều này vẫn chưa thể compile.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-22: Gọi <code>search</code> hoặc
<code>search_case_insensitive</code> dựa trên giá trị trong <code>config.ignore_case</code></span></p>
<p>Cuối cùng, chúng ta cần kiểm tra biến môi trường. Các hàm làm việc với
biến môi trường nằm trong module <code>env</code> của thư viện chuẩn, vì vậy chúng ta
mang module đó vào phạm vi ở đầu <em>src/lib.rs</em>. Sau đó, chúng ta sẽ sử dụng
hàm <code>var</code> từ module <code>env</code> để kiểm tra xem có giá trị nào đã được đặt cho
biến môi trường có tên <code>IGNORE_CASE</code> hay không, như được hiển thị trong
Listing 12-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-23: Kiểm tra giá trị trong biến môi trường
có tên <code>IGNORE_CASE</code></span></p>
<p>Ở đây, chúng ta tạo một biến mới <code>ignore_case</code>. Để gán giá trị cho nó, chúng
ta gọi hàm <code>env::var</code> và truyền vào tên của biến môi trường <code>IGNORE_CASE</code>.
Hàm <code>env::var</code> trả về một <code>Result</code> sẽ là biến thể <code>Ok</code> chứa giá trị của
biến môi trường nếu biến môi trường đó được đặt bất kỳ giá trị nào. Nó sẽ
trả về biến thể <code>Err</code> nếu biến môi trường không được đặt.</p>
<p>Chúng ta sử dụng phương thức <code>is_ok</code> trên <code>Result</code> để kiểm tra xem biến
môi trường có được đặt hay không, nghĩa là chương trình sẽ thực hiện tìm
kiếm không phân biệt chữ hoa chữ thường. Nếu biến môi trường <code>IGNORE_CASE</code>
không được đặt giá trị gì, <code>is_ok</code> sẽ trả về false và chương trình sẽ thực
hiện tìm kiếm phân biệt chữ hoa chữ thường. Chúng ta không quan tâm đến
<em>giá trị</em> của biến môi trường, chỉ quan tâm xem nó đã được đặt hay chưa, nên
chúng ta kiểm tra <code>is_ok</code> thay vì sử dụng <code>unwrap</code>, <code>expect</code> hay bất kỳ
phương thức nào khác mà chúng ta đã thấy trên <code>Result</code>.</p>
<p>Chúng ta truyền giá trị trong biến <code>ignore_case</code> vào instance của <code>Config</code> để
hàm <code>run</code> có thể đọc giá trị đó và quyết định có gọi <code>search_case_insensitive</code>
hay <code>search</code>, như chúng ta đã triển khai trong Listing 12-22.</p>
<p>Hãy thử xem! Trước tiên, chúng ta sẽ chạy chương trình mà không đặt biến
môi trường và với truy vấn <code>to</code>, điều này sẽ khớp với bất kỳ dòng nào
chứa từ “to” viết thường:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Có vẻ như chương trình vẫn hoạt động! Bây giờ, hãy chạy chương trình với
<code>IGNORE_CASE</code> được đặt thành <code>1</code> nhưng với cùng truy vấn <code>to</code>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Nếu bạn đang sử dụng PowerShell, bạn sẽ cần đặt biến môi trường và
chạy chương trình như hai lệnh riêng biệt:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Điều này sẽ làm cho <code>IGNORE_CASE</code> tồn tại trong suốt phiên làm việc shell
của bạn. Nó có thể được hủy bằng cmdlet <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Chúng ta sẽ nhận được các dòng chứa “to” mà có thể có chữ hoa:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Tuyệt vời, chúng ta cũng nhận được các dòng chứa “To”! Chương trình <code>minigrep</code>
của chúng ta bây giờ có thể thực hiện tìm kiếm không phân biệt chữ hoa chữ
thường được điều khiển bởi một biến môi trường. Bây giờ bạn đã biết cách
quản lý các tùy chọn được đặt thông qua đối số dòng lệnh hoặc biến môi
trường.</p>
<p>Một số chương trình cho phép sử dụng cả đối số <em>và</em> biến môi trường cho
cùng một cấu hình. Trong những trường hợp đó, chương trình sẽ quyết định
biến nào được ưu tiên. Để luyện tập thêm, bạn có thể thử điều khiển
việc phân biệt chữ hoa chữ thường thông qua đối số dòng lệnh hoặc biến
môi trường. Quyết định xem đối số dòng lệnh hay biến môi trường sẽ được
ưu tiên nếu chương trình được chạy với một cái đặt phân biệt chữ hoa
chữ thường và cái còn lại đặt không phân biệt.</p>
<p>Module <code>std::env</code> còn chứa nhiều tính năng hữu ích khác để làm việc với
các biến môi trường: hãy tham khảo tài liệu của nó để xem những gì
có sẵn.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-06-writing-to-stderr-instead-of-stdout.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-06-writing-to-stderr-instead-of-stdout.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
