<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bringing Paths Into Scope with the use Keyword - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Đưa-paths-vào-scope-bằng-từ-khóa-use"><a class="header" href="#Đưa-paths-vào-scope-bằng-từ-khóa-use">Đưa Paths vào Scope bằng từ khóa <code>use</code></a></h2>
<p>Phải viết ra đường dẫn để gọi các hàm có thể cảm thấy không tiện lợi và lặp đi
lặp lại. Trong Listing 7-7, dù chúng ta đã chọn đường dẫn tuyệt đối hay tương
đối đến hàm <code>add_to_waitlist</code>, mỗi khi chúng ta muốn gọi <code>add_to_waitlist</code> chúng
ta phải chỉ định <code>front_of_house</code> và <code>hosting</code> nữa. May mắn thay, có một cách để
giảm bớt quá trình này: chúng ta có thể tạo một đường dẫn tắt với từ khóa <code>use</code>
một lần, và sau đó sử dụng tên ngắn hơn ở mọi nơi trong scope.</p>
<p>Trong Listing 7-11, chúng ta đưa module <code>crate::front_of_house::hosting</code> vào
scope của hàm <code>eat_at_restaurant</code> để chúng ta chỉ cần chỉ định
<code>hosting::add_to_waitlist</code> để gọi hàm <code>add_to_waitlist</code> trong
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listing 7-11: Mang một module vào scope với <code>use</code></span></p>
<p>Thêm <code>use</code> và đường dẫn trong một scope giống như tạo một liên kết tượng trưng
trong hệ thống tệp. Bằng cách thêm <code>use crate::front_of_house::hosting</code> trong
crate root, <code>hosting</code> là một tên hợp lệ trong scope đó, giống như module
<code>hosting</code> đã được định nghĩa trong crate root. Đường dẫn được đưa vào scope
với <code>use</code> cũng kiểm tra quyền riêng tư, giống như bất kỳ đường dẫn nào khác.</p>
<p>Lưu ý rằng <code>use</code> chỉ tạo đường dẫn tắt cho scope cụ thể mà <code>use</code> xảy ra. Listing
7-12 di chuyển hàm <code>eat_at_restaurant</code> vào một module con mới có tên
<code>customer</code>, đó là một scope khác với câu lệnh <code>use</code>, vì vậy nội dung hàm sẽ không được biên dịch:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<p><span class="caption">Listing 7-12: Một câu lệnh <code>use</code> chỉ áp dụng trong scope
nó đang ở</span></p>
<p>Lỗi biên dịch cho thấy đường dẫn tắt không còn áp dụng trong module <code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Lưu ý rằng còn có một cảnh báo rằng <code>use</code> không còn được sử dụng trong scope
của nó! Để sửa vấn đề này, di chuyển <code>use</code> trong module <code>customer</code> nữa, hoặc
tham chiếu đến đường dẫn tắt trong module cha với <code>super::hosting</code> trong module
con <code>customer</code>.</p>
<h3 id="tạo-các-use-paths-theo-phong-cách-idiomatic"><a class="header" href="#tạo-các-use-paths-theo-phong-cách-idiomatic">Tạo các <code>use</code> Paths theo phong cách idiomatic</a></h3>
<p>Trong Listing 7-11, bạn có thể đã thắc mắc tại sao chúng ta chỉ định <code>use crate::front_of_house::hosting</code> và sau đó gọi <code>hosting::add_to_waitlist</code> trong
<code>eat_at_restaurant</code> thay vì chỉ định đường dẫn <code>use</code> đến hàm <code>add_to_waitlist</code>
để đạt được kết quả giống như trong Listing 7-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<p><span class="caption">Listing 7-13: Đưa hàm <code>add_to_waitlist</code> vào scope với
<code>use</code>, điều này không thường được dùng</span></p>
<p>Mặc dù cả Listing 7-11 và 7-13 đều đạt được cùng một nhiệm vụ, Listing 7-11 là
cách hợp lệ để đưa một hàm vào scope với <code>use</code>. Đưa module cha của hàm vào scope
với <code>use</code> có nghĩa là chúng ta phải chỉ định module cha khi gọi hàm. Chỉ định
module cha khi gọi hàm làm rõ ràng rằng hàm không được định nghĩa cục bộ trong
lúc vẫn giảm thiểu sự lặp lại của đường dẫn đầy đủ. Mã trong Listing 7-13 không
rõ ràng về nơi <code>add_to_waitlist</code> được định nghĩa.</p>
<p>Mặt khác, khi đưa vào struct, enum, và các mục khác với <code>use</code>, hợp lý là chỉ
định đường dẫn đầy đủ. Listing 7-14 cho thấy cách hợp lý để đưa struct <code>HashMap</code>
của thư viện chuẩn vào scope của một binary crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Listing 7-14: Đưa <code>HashMap</code> vào scope một cách hợp lý</span></p>
<p>Không có lý do nào mạnh mẽ đằng sau quy tắc này: nó chỉ là quy ước đã xuất hiện
và mọi người đã quen với việc đọc và viết mã Rust theo cách này.</p>
<p>Ngoại lệ cho quy tắc này là nếu chúng ta đưa hai mục cùng tên vào scope với
câu lệnh <code>use</code>, vì Rust không cho phép điều đó. Listing 7-15 cho thấy cách để
đưa hai loại <code>Result</code> vào scope mà cùng tên nhưng module cha khác nhau và cách
tham chiếu đến chúng.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listing 7-15: Đưa hai loại cùng tên vào scope cùng một
lúc yêu cầu sử dụng module cha của chúng.</span></p>
<p>Như bạn có thể thấy, sử dụng module cha để phân biệt hai loại <code>Result</code>. Nếu
thay vì đó chúng ta chỉ định <code>use std::fmt::Result</code> và <code>use std::io::Result</code>,
chúng ta sẽ có hai loại <code>Result</code> trong cùng một scope và Rust sẽ không biết
chúng ta muốn loại nào khi chúng ta sử dụng <code>Result</code>.</p>
<hr />
<h3 id="cung-cấp-tên-mới-bằng-từ-khóa-as"><a class="header" href="#cung-cấp-tên-mới-bằng-từ-khóa-as">Cung cấp tên mới bằng từ khóa <code>as</code></a></h3>
<p>Có một cách khác để giải quyết vấn đề đưa hai loại cùng tên vào cùng một scope
với <code>use</code>: sau đường dẫn, chúng ta có thể chỉ định <code>as</code> và một tên cục bộ mới,
hoặc <em>bí danh</em>, cho loại. Listing 7-16 cho thấy một cách khác để viết code trong
Listing 7-15 bằng cách đổi tên một trong hai loại <code>Result</code> sử dụng <code>as</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listing 7-16: Đổi tên một loại khi nó được đưa vào scope
sử dụng từ khóa <code>as</code></span></p>
<p>Trong câu lệnh <code>use</code> thứ hai, chúng ta đã chọn tên mới <code>IoResult</code> cho loại
<code>std::io::Result</code>, nó sẽ không xung đột với <code>Result</code> từ <code>std::fmt</code> mà chúng ta
cũng đã đưa vào scope. Listing 7-15 và Listing 7-16 được xem là tiêu chuẩn, vì
vậy bạn có thể chọn một trong hai!</p>
<h3 id="re-exporting-names-with-pub-use"><a class="header" href="#re-exporting-names-with-pub-use">Re-exporting Names with <code>pub use</code></a></h3>
<p>Khi chúng ta dùng từ khóa <code>use</code>, tên mới được đưa vào chỉ hiện diện bên
trong scope mà <code>use</code> được gọi. Để cho phép code bên ngoài có thể gọi đến tên đó
chúng ta có thể kết hợp <code>pub</code> và <code>use</code>. Kỹ thuật này được gọi là
<em>export lại(re-exporting)</em> vì chúng ta đang đưa một item vào scope nhưng cũng
làm cho item đó có sẵn cho người khác để đưa vào scope của họ.</p>
<p>Listing 7-17 cho thấy code trong Listing 7-11 với <code>use</code> trong module gốc được
đổi thành <code>pub use</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listing 7-17: Làm cho một tên có sẵn cho bất kỳ code nào
để sử dụng từ một scope mới với <code>pub use</code></span></p>
<p>Trước khi thay đổi này diễn ra, code bên ngoài phải gọi hàm <code>add_to_waitlist</code>
bằng cách sử dụng đường dẫn
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>. Bây giờ vì <code>pub use</code>
đã export lại module <code>hosting</code> từ module gốc, code bên ngoài có thể sử dụng
đường dẫn <code>restaurant::hosting::add_to_waitlist()</code> thay vì đường dẫn cũ.</p>
<p>Re-exporting rất hữu ích khi cấu trúc bên trong code của bạn khác với cách
lập trình viên gọi code của bạn sẽ nghĩ về domain. Ví dụ, trong thí dụ nhà hàng
ở trên, người điều hành nhà hàng nghĩ về “front of house” và “back of house”.
Nhưng khách hàng đến nhà hàng có thể không nghĩ về các phần của nhà hàng theo
cách đó. Với <code>pub use</code>, chúng ta có thể viết code của mình với một cấu trúc
nhưng sẽ cho thấy một cấu trúc khác. Việc làm như vậy giúp code của chúng ta
được tổ chức tốt cho cả các lập trình viên làm việc trên code của chúng ta và
các lập trình viên gọi code của chúng ta. Chúng ta sẽ xem một ví dụ khác về
<code>pub use</code> và cách nó ảnh hưởng đến tài liệu của crate của bạn trong phần
<a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">“Exporting a Convenient Public API with <code>pub use</code>”</a><!-- ignore --> của Chapter 14.</p>
<h3 id="re-exporting-names-với-pub-use"><a class="header" href="#re-exporting-names-với-pub-use">Re-exporting Names với <code>pub use</code></a></h3>
<p>Trong chương 2, chúng ta đã viết một project đoán số sử dụng một package bên
ngoài gọi là <code>rand</code> để lấy ra các số ngẫu nhiên. Để sử dụng <code>rand</code> trong
project của chúng ta, chúng ta đã thêm dòng này vào <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
<p>Thêm <code>rand</code> làm một dependency trong <em>Cargo.toml</em> cho biết Cargo sẽ tải về
package <code>rand</code> và bất kỳ dependencies nào từ <a href="https://crates.io/">crates.io</a> và
cho phép <code>rand</code> có sẵn để dùng trong project của chúng ta.</p>
<p>Sau đó, để cho phép <code>rand</code> có thể được sử dụng trong scope của package,
chúng ta đã thêm một dòng <code>use</code> bắt đầu với tên của crate, <code>rand</code>, và liệt kê
những item mà chúng ta muốn cho phép sử dụng trong scope. Nhớ lại trong phần
<a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Generating a Random Number”</a><!-- ignore --> của chương 2, chúng ta đã
import trait <code>Rng</code> vào scope và gọi hàm <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>Thành viên của cộng đồng Rust đã làm rất nhiều package có sẵn tại
<a href="https://crates.io/">crates.io</a>, và để sử dụng bất kỳ package nào trong
package của bạn, bạn chỉ cần làm những bước tương tự như trên: liệt kê chúng
trong file <em>Cargo.toml</em> của package và sử dụng <code>use</code> để import các item từ
package đó vào scope.</p>
<p>Lưu ý rằng thư viện chuẩn <code>std</code> cũng là một crate bên ngoài package của chúng
ta. Vì thư viện chuẩn được cung cấp cùng với ngôn ngữ Rust, chúng ta không cần
phải thay đổi <em>Cargo.toml</em> để bao gồm <code>std</code>. Nhưng chúng ta cần phải tham chiếu
đến nó với <code>use</code> để import các item từ đó vào scope của package của chúng ta.
Ví dụ, với <code>HashMap</code> chúng ta sẽ sử dụng dòng này:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Đây là một đường dẫn tuyệt đối bắt đầu với <code>std</code>, tên của crate thư viện chuẩn.</p>
<h3 id="sử-dụng-nested-paths-để-làm-gọn-các-danh-sách-use-lớn"><a class="header" href="#sử-dụng-nested-paths-để-làm-gọn-các-danh-sách-use-lớn">Sử dụng Nested Paths để làm gọn các danh sách <code>use</code> lớn</a></h3>
<p>Nếu chúng ta sử dụng nhiều item được định nghĩa trong cùng một crate hoặc cùng
một module, việc liệt kê mỗi item trên một dòng riêng sẽ chiếm rất nhiều không
gian dọc trong file của chúng ta. Ví dụ, hai dòng <code>use</code> này chúng ta có trong
game đoán số ở Listing 2-4 import các item từ <code>std</code> vào scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Thay vì đó, chúng ta có thể sử dụng đường dẫn lồng nhau để import các item
cùng vào scope trong một dòng. Chúng ta làm điều này bằng cách chỉ định phần
chung của đường dẫn, theo sau bởi hai dấu hai chấm, và sau đó là dấu ngoặc nhọn
xung quanh một danh sách các phần của đường dẫn khác nhau, như trong Listing
7-18.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 7-18: Khai báo một đường dẫn lồng nhau để import
nhiều item cùng với cùng một tiền tố vào scope</span></p>
<p>Trong các chương trình lớn hơn, việc import nhiều item từ cùng một crate hoặc
module sử dụng đường dẫn lồng nhau có thể giảm số lượng các dòng <code>use</code> riêng
biệt rất nhiều.</p>
<p>Chúng ta có thể sử dụng một đường dẫn lồng nhau ở bất kỳ mức độ nào trong một
đường dẫn, điều này rất hữu ích khi kết hợp hai dòng <code>use</code> chia sẻ một đường
dẫn con. Ví dụ, Listing 7-19 cho thấy hai dòng <code>use</code>: một trong đó import
<code>std::io</code> vào scope và một trong đó import <code>std::io::Write</code> vào scope.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<p><span class="caption">Listing 7-19: Hai dòng <code>use</code> trong đó một là một đường
dẫn con của đường dẫn khác</span></p>
<p>Phần chung của hai đường dẫn này là <code>std::io</code>, và đó là đường dẫn đầu tiên
hoàn chỉnh. Để kết hợp hai đường dẫn này thành một dòng <code>use</code>, chúng ta có thể
sử dụng <code>self</code> trong đường dẫn lồng nhau, như trong Listing 7-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<p><span class="caption">Listing 7-20: Kết hợp đường dẫn trong Listing 7-19 thành
một dòng <code>use</code></span></p>
<p>Dòng này import <code>std::io</code> và <code>std::io::Write</code> vào scope.</p>
<h3 id="toán-tử-glob"><a class="header" href="#toán-tử-glob">Toán tử Glob</a></h3>
<p>Nếu chúng ta muốn import <em>tất cả</em> các mục công khai được định nghĩa trong một
đường dẫn vào scope, chúng ta có thể chỉ định đường dẫn đó theo sau bởi toán
tử <code>*</code> glob:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Dòng <code>use</code> này import tất cả các mục công khai được định nghĩa trong
<code>std::collections</code> vào scope hiện tại. Hãy cẩn thận khi sử dụng toán tử glob!
Toán tử glob có thể làm cho việc biết được tên nào đang trong scope và nơi một
tên được sử dụng trong chương trình của bạn được định nghĩa trở nên khó khăn
hơn.</p>
<p>Toán tử glob thường được sử dụng khi kiểm thử để import tất cả mọi thứ dưới
kiểm thử vào module <code>tests</code>; chúng ta sẽ nói về điều đó trong phần
<a href="ch11-01-writing-tests.html#how-to-write-tests">“How to Write Tests”</a><!-- ignore --> trong Chương 11. Toán tử
glob cũng được sử dụng đôi khi là một phần của pattern prelude: xem
<a href="../std/prelude/index.html#other-preludes">documentation của thư viện chuẩn</a><!-- ignore --> để biết thêm thông tin về pattern đó.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
