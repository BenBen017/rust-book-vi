<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Một ví dụ về lập trình với Struct - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="một-chương-trình-minh-họa-sử-dụng-struct"><a class="header" href="#một-chương-trình-minh-họa-sử-dụng-struct">Một Chương Trình Minh Họa Sử Dụng Struct</a></h2>
<p>Để hiểu khi nào chúng ta nên sử dụng struct, hãy viết một chương trình tính
diện tích của một hình chữ nhật. Chúng ta sẽ bắt đầu bằng cách sử dụng các
biến đơn, sau đó làm lại chương trình cho đến khi sử dụng struct.</p>
<p>Hãy tạo một dự án binary mới với Cargo gọi là <em>rectangles</em> để nhận chiều rộng
và chiều cao của một hình chữ nhật được chỉ định bằng pixel và tính diện tích
của hình chữ nhật đó. Code ở Listing 5-8 hiển thị một chương trình ngắn có một
cách làm như vậy trong file <em>src/main.rs</em> của dự án của chúng ta.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<p><span class="caption">Listing 5-8: Tính diện tích của hình chữ nhật được chỉ
định bởi các biến chiều rộng và chiều cao riêng lẻ</span></p>
<p>Giờ chạy chương trình này bằng cách sử dụng <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Mã này thành công trong việc tính diện tích của hình chữ nhật bằng cách gọi hàm <code>area</code> với mỗi chiều, nhưng chúng ta có thể làm thêm để làm cho mã này rõ ràng và dễ đọc hơn.</p>
<p>Vấn đề của mã này rõ ràng trong chữ ký của <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "The area of the rectangle is {} square pixels.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>Hàm <code>area</code> được thiết kế để tính diện tích của một hình chữ nhật, nhưng hàm
mà chúng ta đã viết có hai tham số và không rõ ở đâu trong chương trình
của chúng ta rằng các tham số này có liên quan. Việc nhóm chiều rộng và
chiều cao lại với nhau sẽ làm cho mã này dễ đọc và quản lý hơn. Chúng ta
đã thảo luận một cách làm như vậy trong <a href="ch03-02-data-types.html#the-tuple-type">“The Tuple Type”</a><!-- ignore -->
trong Chương 3: sử dụng tuples.</p>
<h3 id="tái-cấu-trúc-với-tuple"><a class="header" href="#tái-cấu-trúc-với-tuple">Tái Cấu Trúc với Tuple</a></h3>
<p>Listing 5-9 hiển thị một phiên bản khác của chương trình của chúng ta sử dụng tuple.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<p><span class="caption">Listing 5-9: Xác định chiều rộng và chiều cao của hình chữ nhật bằng tuple</span></p>
<p>Ở một cách, chương trình này tốt hơn. Tuple cho phép chúng ta thêm một chút
cấu trúc và giờ đây chúng ta chỉ đang truyền một đối số. Nhưng theo một cách khác,
phiên bản này lại ít rõ ràng: tuples không đặt tên cho các phần tử của chúng,
vì vậy chúng ta phải sử dụng chỉ mục vào các phần của tuple, làm cho phép tính
toán của chúng ta ít rõ ràng hơn.</p>
<p>Việc nhầm lẫn giữa chiều rộng và chiều cao có thể không quan trọng đối
với việc tính diện tích, nhưng nếu chúng ta muốn vẽ hình chữ nhật
lên màn hình, điều đó sẽ quan trọng! Chúng ta sẽ phải nhớ rằng width
là chỉ mục 0 của tuple và <code>height</code> là chỉ mục <code>1</code> của tuple. Điều này sẽ làm
cho người khác khó khăn hơn khi cố gắng hiểu và giữ mã của chúng ta.
Bởi vì chúng ta chưa truyền đạt ý nghĩa của dữ liệu trong mã của chúng ta,
việc giới thiệu lỗi giờ đây dễ dàng hơn.</p>
<h3 id="tái-cấu-trúc-với-structs-thêm-nhiều-Ý-nghĩa-hơn"><a class="header" href="#tái-cấu-trúc-với-structs-thêm-nhiều-Ý-nghĩa-hơn">Tái Cấu Trúc với Structs: Thêm Nhiều Ý Nghĩa Hơn</a></h3>
<p>Chúng ta sử dụng structs để thêm ý nghĩa bằng cách đặt tên cho dữ liệu. Chúng ta
có thể chuyển đổi tuple chúng ta đang sử dụng thành một struct có tên cho toàn bộ
cũng như tên cho các phần, như thể hiện trong Listing 5-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<p><span class="caption">Listing 5-10: Định nghĩa một struct <code>Rectangle</code></span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly
brackets, we defined the fields as <code>width</code> and <code>height</code>, both of which have
type <code>u32</code>. Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code>
that has a width of <code>30</code> and a height of <code>50</code>.</p>
<p>Our <code>area</code> function is now defined with one parameter, which we’ve named
<code>rectangle</code>, whose type is an immutable borrow of a struct <code>Rectangle</code>
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, <code>main</code> retains its ownership and can continue
using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the function signature and
where we call the function.</p>
<p>The <code>area</code> function accesses the <code>width</code> and <code>height</code> fields of the <code>Rectangle</code>
instance (note that accessing fields of a borrowed struct instance does not
move the field values, which is why you often see borrows of structs). Our
function signature for <code>area</code> now says exactly what we mean: calculate the area
of <code>Rectangle</code>, using its <code>width</code> and <code>height</code> fields. This conveys that the
width and height are related to each other, and it gives descriptive names to
the values rather than using the tuple index values of <code>0</code> and <code>1</code>. This is a
win for clarity.</p>
<p>Ở đây, chúng ta đã định nghĩa một struct và đặt tên cho nó là <code>Rectangle</code>.
Bên trong dấu ngoặc nhọn, chúng ta đã xác định các trường là <code>width</code> và <code>height</code>,
cả hai đều có kiểu <code>u32</code>. Sau đó, trong hàm <code>main</code>, chúng ta đã tạo một instance
cụ thể của <code>Rectangle</code> có chiều rộng là <code>30</code> và chiều cao là <code>50</code>.</p>
<p>Hàm <code>area</code> của chúng ta giờ đây được định nghĩa với một tham số, mà chúng ta
đã đặt tên là rectangle, kiểu dữ liệu của nó là một borrow không thể thay đổi
(immutable borrow) của một thể hiện của struct <code>Rectangle</code>. Như đã đề cập
trong Chương 4, chúng ta muốn mượn (borrow) struct thay vì sở hữu nó. Điều này
giúp cho hàm main giữ quyền sở hữu và có thể tiếp tục sử dụng rect1, đó là lý do
chúng ta sử dụng ký hiệu &amp; trong chữ ký hàm và ở nơi chúng ta gọi hàm.</p>
<p>Hàm area truy cập các trường <code>width</code> và <code>height</code> của thể hiện <code>Rectangle</code> (lưu ý rằng
việc truy cập các trường của một thể hiện struct đã được mượn không di chuyển
giá trị trường, đó là lý do tại sao bạn thường thấy việc mượn struct). Chữ ký hàm
cho area bây giờ diễn đạt đúng ý chúng ta: tính diện tích của <code>Rectangle</code>, sử dụng
các trường <code>width</code> và <code>height</code> của nó. Điều này truyền đạt rằng chiều rộng và chiều cao
có liên quan đến nhau, và nó đặt tên mô tả cho các giá trị thay vì sử dụng chỉ mục
tuple là <code>0</code> và <code>1</code>. Điều này là một chiến thắng về sự rõ ràng.</p>
<h3 id="thêm-chức-năng-hữu-Ích-với-các-derived-traits"><a class="header" href="#thêm-chức-năng-hữu-Ích-với-các-derived-traits">Thêm Chức Năng Hữu Ích với Các Derived Traits</a></h3>
<p>Sẽ hữu ích nếu chúng ta có thể in ra một thể hiện của <code>Rectangle</code> trong khi chúng ta
đang gỡ lỗi chương trình và xem giá trị của tất cả các trường. Đoạn mã 5-11
thử nghiệm việc sử dụng <a href="../std/macro.println.html">macro println!</a><!-- ignore --> như chúng ta
đã sử dụng trong các chương trước đó. Tuy nhiên, điều này sẽ không hoạt động.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1}");
}</code></pre>
<p><span class="caption">Listing 5-11: Thử in ra một instance <code>Rectangle</code></span></p>
<p>Khi chúng ta biên dịch mã này, chúng ta sẽ nhận được một lỗi với thông báo chính sau:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Macro <code>println!</code> có thể thực hiện nhiều loại định dạng, và theo mặc định, dấu ngoặc nhọn
trong <code>println!</code> đều cho biết chúng ta muốn sử dụng định dạng được biết đến là <code>Display</code>:
định dạng đầu ra dành cho việc tiêu thụ trực tiếp bởi người dùng cuối. Các kiểu dữ liệu
nguyên thủy mà chúng ta đã thấy cho đến nay mặc định triển khai Display vì chỉ có một
cách bạn muốn hiển thị một 1 hoặc bất kỳ loại nguyên thủy nào khác cho người dùng. Nhưng với struct,
cách <code>println!</code> nên định dạng đầu ra là không rõ ràng hơn vì có nhiều khả năng hiển
thị: bạn có muốn có dấu phẩy hay không? Bạn muốn in các dấu ngoặc nhọn không? Tất
cả các trường có nên được hiển thị không? Do sự mơ hồ này, Rust không cố gắng đoán xem
chúng ta muốn gì, và structs không có một triển khai Display được cung cấp để sử dụng
với <code>println!</code> và <code>{}</code> placeholder.</p>
<p>Nếu chúng ta tiếp tục đọc lỗi, chúng ta sẽ thấy một ghi chú hữu ích này:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Hãy thử nó xem! Lời gọi macro <code>println!</code> bây giờ sẽ trông như <code>println!("rect1 is {:?}", rect1);</code>.
Đặt specifier <code>:?</code> bên trong dấu ngoặc nhọn cho biết cho <code>println!</code> rằng chúng ta muốn
sử dụng một định dạng đầu ra được gọi là <code>Debug</code>. Trait <code>Debug</code> cho phép chúng ta
in ra struct của mình một cách hữu ích cho các nhà phát triển để chúng ta có thể
thấy giá trị của nó trong khi chúng ta đang gỡ lỗi mã của mình.</p>
<p>Biên dịch mã với thay đổi này. Cmn :D! Chúng ta vẫn gặp một lỗi:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Nhưng một lần nữa, trình biên dịch lại cung cấp cho chúng ta một ghi chú hữu ích:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>thực sự</em> bao gồm chức năng in ra thông tin gỡ lỗi, nhưng chúng ta phải chọn
một cách tường minh (opt in) để làm cho chức năng này có sẵn cho struct của chúng ta.
Để làm điều đó, chúng ta thêm thuộc tính bên ngoài <code>#[derive(Debug)]</code> ngay trước
định nghĩa của struct, như thể hiện trong Đoạn mã 5-12.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}</code></pre></pre>
<p><span class="caption">Listing 5-12: Thêm thuộc tính để tạo ra <code>Debug</code> trait và
in ra instance của <code>Rectangle</code> sử dụng định dạng gỡ lỗi(Debug).</span></p>
<p>Now when we run the program, we won’t get any errors, and we’ll see the
following output:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Tuyệt vời! Đây không phải là output đẹp nhất, nhưng nó hiển thị giá trị của
tất cả các trường cho thể hiện này, điều này chắc chắn sẽ giúp trong quá trình gỡ lỗi.
Khi chúng ta có các struct lớn hơn, việc có output dễ đọc hơn một chút
sẽ hữu ích; trong những trường hợp đó, chúng ta có thể sử dụng <code>{:#?}</code>
thay vì <code>{:?}</code> trong chuỗi <code>println!</code>. Trong ví dụ này, sử dụng kiểu <code>{:#?}</code> sẽ
xuất ra như sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Một cách khác để in ra một giá trị sử dụng định dạng <code>Debug</code> là sử dụng <a href="../std/macro.dbg.html">dbg!
macro</a><!-- ignore -->, nó lấy quyền sở hữu của một biểu thức (so với
<code>println!</code>, nó lấy một tham chiếu), in ra số dòng và tên tệp của nơi cuộc gọi
macro <code>dbg!</code> xuất hiện trong mã của bạn cùng với giá trị kết quả của biểu thức
đó và trả lại quyền sở hữu của giá trị.</p>
<blockquote>
<p>Lưu ý: Gọi macro <code>dbg!</code> in ra luồng console lỗi tiêu chuẩn (<code>stderr</code>), khác với
<code>println!</code>, nó in ra luồng console đầu ra tiêu chuẩn (<code>stdout</code>). Chúng ta sẽ
thảo luận thêm về <code>stderr</code> và <code>stdout</code> trong phần <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">“Viết các Thông báo Lỗi vào
Luồng Lỗi Tiêu Chuẩn Thay vì Luồng Đầu Ra Tiêu Chuẩn” trong Chương 12</a><!-- ignore -->.</p>
</blockquote>
<p>Dưới đây là một ví dụ trong đó chúng ta quan tâm đến giá trị được gán cho
trường <code>width</code>, cũng như giá trị của toàn bộ struct trong <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>Chúng ta có thể đặt <code>dbg!</code> xung quanh biểu thức <code>30 * scale</code> và, vì <code>dbg!</code>
trả lại quyền sở hữu của giá trị của biểu thức, trường <code>width</code> sẽ có giá trị
giống như khi chúng ta không có lời gọi <code>dbg!</code> ở đó. Chúng ta không muốn
<code>dbg!</code> sở hữu <code>rect1</code>, nên chúng ta sử dụng một tham chiếu đến <code>rect1</code> trong
lời gọi tiếp theo. Dưới đây là đầu ra của ví dụ này:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>We can see the first bit of output came from <em>src/main.rs</em> line 10 where we’re
debugging the expression <code>30 * scale</code>, and its resultant value is <code>60</code> (the
<code>Debug</code> formatting implemented for integers is to print only their value). The
<code>dbg!</code> call on line 14 of <em>src/main.rs</em> outputs the value of <code>&amp;rect1</code>, which is
the <code>Rectangle</code> struct. This output uses the pretty <code>Debug</code> formatting of the
<code>Rectangle</code> type. The <code>dbg!</code> macro can be really helpful when you’re trying to
figure out what your code is doing!</p>
<p>In addition to the <code>Debug</code> trait, Rust has provided a number of traits for us
to use with the <code>derive</code> attribute that can add useful behavior to our custom
types. Those traits and their behaviors are listed in <a href="appendix-03-derivable-traits.html">Appendix C</a><!--
ignore -->. We’ll cover how to implement these traits with custom behavior as
well as how to create your own traits in Chapter 10. There are also many
attributes other than <code>derive</code>; for more information, see <a href="../reference/attributes.html">the “Attributes”
section of the Rust Reference</a>.</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our <code>Rectangle</code> struct
because it won’t work with any other type. Let’s look at how we can continue to
refactor this code by turning the <code>area</code> function into an <code>area</code> <em>method</em>
defined on our <code>Rectangle</code> type.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-01-defining-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-03-method-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-01-defining-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-03-method-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
