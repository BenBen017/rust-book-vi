<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Developing the Library’s Functionality with Test Driven Development - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="phát-triển-chức-năng-của-thư-viện-với-phát-triển-theo-kiểm-tra-tdd"><a class="header" href="#phát-triển-chức-năng-của-thư-viện-với-phát-triển-theo-kiểm-tra-tdd">Phát Triển Chức Năng Của Thư Viện Với Phát Triển Theo Kiểm Tra (TDD)</a></h2>
<p>Bây giờ chúng ta đã tách logic vào <em>src/lib.rs</em> và giữ phần thu thập đối số và xử lý lỗi trong <em>src/main.rs</em>, việc viết test cho chức năng cốt lõi của mã trở nên dễ dàng hơn nhiều. Chúng ta có thể gọi trực tiếp các hàm với các đối số khác nhau và kiểm tra giá trị trả về mà không cần phải gọi binary từ dòng lệnh.</p>
<p>Trong phần này, chúng ta sẽ thêm logic tìm kiếm vào chương trình <code>minigrep</code> bằng quy trình phát triển theo kiểm tra (test-driven development, TDD) với các bước sau:</p>
<ol>
<li>Viết một test mà sẽ thất bại và chạy nó để đảm bảo nó thất bại vì lý do bạn mong đợi.</li>
<li>Viết hoặc sửa đổi đủ mã để test mới này thành công.</li>
<li>Refactor mã vừa thêm hoặc thay đổi và đảm bảo các test vẫn chạy đúng.</li>
<li>Lặp lại từ bước 1!</li>
</ol>
<p>Mặc dù đây chỉ là một trong nhiều cách viết phần mềm, TDD có thể giúp định hướng thiết kế mã. Viết test trước khi viết mã làm test đó thành công giúp duy trì độ bao phủ test cao trong suốt quá trình.</p>
<p>Chúng ta sẽ viết test để điều khiển việc triển khai chức năng thực sự sẽ tìm kiếm chuỗi query trong nội dung file và tạo ra danh sách các dòng khớp với query. Chúng ta sẽ thêm chức năng này trong một hàm có tên <code>search</code>.</p>
<h3 id="viết-một-test-thất-bại"><a class="header" href="#viết-một-test-thất-bại">Viết Một Test Thất Bại</a></h3>
<p>Vì chúng ta không còn cần chúng nữa, hãy loại bỏ các câu lệnh <code>println!</code> từ <em>src/lib.rs</em> và <em>src/main.rs</em> mà chúng ta đã dùng để kiểm tra hành vi của chương trình. Sau đó, trong <em>src/lib.rs</em>, thêm một module <code>tests</code> với một hàm test, như chúng ta đã làm trong <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">Chương 11</a><!-- ignore -->. Hàm test chỉ định hành vi mà chúng ta muốn hàm <code>search</code> có: nó sẽ nhận một query và văn bản cần tìm kiếm, và trả về chỉ các dòng từ văn bản chứa query. Listing 12-15 trình bày test này, mã này hiện chưa biên dịch được.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
<p><span class="caption">Listing 12-15: Tạo một test thất bại cho hàm <code>search</code> mà chúng ta mong muốn có</span></p>
<p>Test này tìm kiếm chuỗi <code>"duct"</code>. Văn bản mà chúng ta đang tìm kiếm có ba dòng, chỉ có một dòng chứa <code>"duct"</code> (Lưu ý rằng dấu gạch chéo ngược <code>\</code> sau dấu ngoặc kép mở cho Rust biết không chèn ký tự newline ở đầu nội dung của literal chuỗi này). Chúng ta khẳng định rằng giá trị trả về từ hàm <code>search</code> chỉ chứa dòng mà chúng ta mong đợi.</p>
<p>Hiện tại chúng ta chưa thể chạy test này và xem nó thất bại vì test thậm chí còn chưa biên dịch được: hàm <code>search</code> vẫn chưa tồn tại! Theo nguyên tắc TDD, chúng ta sẽ thêm đủ mã để test có thể biên dịch và chạy bằng cách thêm định nghĩa hàm <code>search</code> luôn trả về một vector rỗng, như trong Listing 12-16. Khi đó, test sẽ biên dịch nhưng thất bại vì một vector rỗng không khớp với vector chứa dòng <code>"safe, fast, productive."</code></p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-16: Định nghĩa đủ hàm <code>search</code> để test của chúng ta có thể biên dịch</span></p>
<p>Lưu ý rằng chúng ta cần định nghĩa một lifetime rõ ràng <code>'a</code> trong chữ ký của hàm <code>search</code> và sử dụng lifetime đó với tham số <code>contents</code> và giá trị trả về. Nhớ lại trong <a href="ch10-03-lifetime-syntax.html">Chương 10</a><!-- ignore --> rằng các tham số lifetime chỉ ra lifetime của tham số nào được kết nối với lifetime của giá trị trả về. Trong trường hợp này, chúng ta chỉ ra rằng vector trả về nên chứa các string slice tham chiếu đến các slice của tham số <code>contents</code> (thay vì tham số <code>query</code>).</p>
<p>Nói cách khác, chúng ta bảo Rust rằng dữ liệu trả về từ hàm <code>search</code> sẽ sống lâu bằng dữ liệu được truyền vào hàm <code>search</code> thông qua tham số <code>contents</code>. Điều này rất quan trọng! Dữ liệu mà một slice tham chiếu <em>bởi</em> nó cần phải hợp lệ để tham chiếu hợp lệ; nếu compiler giả sử chúng ta tạo các string slice từ <code>query</code> thay vì <code>contents</code>, nó sẽ kiểm tra an toàn sai cách.</p>
<p>Nếu chúng ta quên các annotation lifetime và cố biên dịch hàm này, chúng ta sẽ nhận được lỗi sau:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:1:51
  |
1 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                      ----            ----         ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
  |
1 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
  |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust không thể biết được chúng ta cần dùng argument nào trong hai argument, vì vậy chúng ta cần chỉ rõ cho nó. Vì <code>contents</code> là argument chứa toàn bộ văn bản và chúng ta muốn trả về các phần của văn bản đó mà khớp với query, nên chúng ta biết <code>contents</code> là argument cần được kết nối với giá trị trả về bằng cú pháp lifetime.</p>
<p>Các ngôn ngữ lập trình khác không yêu cầu bạn kết nối argument với giá trị trả về trong chữ ký hàm, nhưng thói quen này sẽ trở nên dễ dàng hơn theo thời gian. Bạn có thể so sánh ví dụ này với phần <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Validating References with Lifetimes”</a><!-- ignore --> trong Chương 10.</p>
<p>Bây giờ hãy chạy test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----

thread 'tests::one_result' panicked at src/lib.rs:17:9:
assertion `left == right` failed
  left: ["safe, fast, productive."]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Tuyệt! Test thất bại, chính xác như chúng ta mong đợi. Bây giờ hãy viết mã để test thành công!</p>
<h3 id="viết-mã-Để-test-thành-công"><a class="header" href="#viết-mã-Để-test-thành-công">Viết Mã Để Test Thành Công</a></h3>
<p>Hiện tại, test của chúng ta thất bại vì chúng ta luôn trả về một vector rỗng. Để sửa lỗi đó và triển khai <code>search</code>, chương trình của chúng ta cần thực hiện các bước sau:</p>
<ul>
<li>Lặp qua từng dòng của nội dung.</li>
<li>Kiểm tra xem dòng đó có chứa chuỗi query không.</li>
<li>Nếu có, thêm nó vào danh sách các giá trị sẽ trả về.</li>
<li>Nếu không, không làm gì.</li>
<li>Trả về danh sách các kết quả khớp.</li>
</ul>
<p>Hãy thực hiện từng bước, bắt đầu với việc lặp qua các dòng.</p>
<h4 id="lặp-qua-các-dòng-với-phương-thức-lines"><a class="header" href="#lặp-qua-các-dòng-với-phương-thức-lines">Lặp Qua Các Dòng Với Phương Thức <code>lines</code></a></h4>
<p>Rust có một phương thức hữu ích để lặp từng dòng của chuỗi, tên là <code>lines</code>, hoạt động như trong Listing 12-17. Lưu ý rằng mã này chưa biên dịch được.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-17: Lặp qua từng dòng trong <code>contents</code></span></p>
<p>Phương thức <code>lines</code> trả về một iterator. Chúng ta sẽ bàn kỹ về iterator trong <a href="ch13-02-iterators.html">Chương 13</a><!-- ignore -->, nhưng hãy nhớ rằng bạn đã thấy cách sử dụng iterator này trong <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Listing 3-5</a><!-- ignore -->, nơi chúng ta dùng vòng lặp <code>for</code> với iterator để chạy một số mã trên từng phần tử trong một collection.</p>
<h4 id="tìm-kiếm-chuỗi-query-trong-mỗi-dòng"><a class="header" href="#tìm-kiếm-chuỗi-query-trong-mỗi-dòng">Tìm Kiếm Chuỗi Query Trong Mỗi Dòng</a></h4>
<p>Tiếp theo, chúng ta sẽ kiểm tra xem dòng hiện tại có chứa chuỗi query không. May mắn là các string có một phương thức hữu ích tên là <code>contains</code> làm việc này cho chúng ta! Thêm một lời gọi đến phương thức <code>contains</code> trong hàm <code>search</code>, như được trình bày trong Listing 12-18. Lưu ý rằng mã này vẫn chưa biên dịch được.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-18: Thêm chức năng kiểm tra xem dòng có chứa chuỗi trong <code>query</code> không</span></p>
<p>Hiện tại, chúng ta đang xây dựng dần chức năng. Để mã biên dịch được, chúng ta cần trả về một giá trị từ thân hàm như đã chỉ ra trong chữ ký hàm.</p>
<h4 id="lưu-các-dòng-khớp"><a class="header" href="#lưu-các-dòng-khớp">Lưu Các Dòng Khớp</a></h4>
<p>Để hoàn thiện hàm này, chúng ta cần một cách lưu các dòng khớp mà muốn trả về. Để làm điều đó, chúng ta có thể tạo một vector mutable trước vòng lặp <code>for</code> và gọi phương thức <code>push</code> để lưu một <code>line</code> vào vector. Sau vòng lặp <code>for</code>, chúng ta trả về vector, như được trình bày trong Listing 12-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-19: Lưu các dòng khớp để có thể trả về chúng</span></p>
<p>Bây giờ, hàm <code>search</code> sẽ chỉ trả về những dòng chứa <code>query</code>, và test của chúng ta sẽ thành công. Hãy chạy test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Test của chúng ta đã thành công, vì vậy chúng ta biết nó hoạt động!</p>
<p>Ở thời điểm này, chúng ta có thể xem xét các cơ hội để refactor việc triển khai hàm search trong khi vẫn giữ các test thành công để duy trì cùng một chức năng. Mã trong hàm search không tệ, nhưng nó chưa tận dụng một số tính năng hữu ích của iterator. Chúng ta sẽ quay lại ví dụ này trong <a href="ch13-02-iterators.html">Chương 13</a><!-- ignore -->, nơi chúng ta sẽ tìm hiểu chi tiết về iterator và xem cách cải thiện nó.</p>
<h4 id="sử-dụng-hàm-search-trong-hàm-run"><a class="header" href="#sử-dụng-hàm-search-trong-hàm-run">Sử dụng hàm <code>search</code> trong hàm <code>run</code></a></h4>
<p>Bây giờ hàm <code>search</code> đã hoạt động và được test, chúng ta cần gọi <code>search</code> từ hàm <code>run</code>. Chúng ta cần truyền giá trị <code>config.query</code> và <code>contents</code> mà <code>run</code> đọc từ file vào hàm <code>search</code>. Sau đó, <code>run</code> sẽ in từng dòng được trả về từ <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Chúng ta vẫn đang sử dụng một vòng lặp <code>for</code> để lấy từng dòng từ <code>search</code> và in ra.</p>
<p>Bây giờ toàn bộ chương trình nên hoạt động! Hãy thử nó, trước tiên với một từ mà sẽ trả về chính xác một dòng từ bài thơ của Emily Dickinson, <code>"frog"</code>:</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Tuyệt! Bây giờ hãy thử một từ sẽ khớp với nhiều dòng, chẳng hạn <code>"body"</code>:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Và cuối cùng, hãy chắc chắn rằng chúng ta không nhận được dòng nào khi tìm kiếm một từ không xuất hiện trong bài thơ, chẳng hạn <code>"monomorphization"</code>:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Tuyệt vời! Chúng ta đã xây dựng phiên bản mini của một công cụ cổ điển và học được rất nhiều về cách cấu trúc ứng dụng. Chúng ta cũng đã tìm hiểu một chút về nhập/xuất file, lifetimes, testing và phân tích tham số dòng lệnh.</p>
<p>Để hoàn thiện dự án này, chúng ta sẽ minh họa ngắn gọn cách làm việc với biến môi trường và cách in ra lỗi chuẩn (standard error), cả hai đều hữu ích khi viết các chương trình dòng lệnh.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-05-working-with-environment-variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-05-working-with-environment-variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
