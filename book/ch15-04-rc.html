<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rc&lt;T&gt;, the Reference Counted Smart Pointer - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="rct-smart-pointer-Đếm-tham-chiếu"><a class="header" href="#rct-smart-pointer-Đếm-tham-chiếu"><code>Rc&lt;T&gt;</code>, Smart Pointer Đếm Tham Chiếu</a></h2>
<p>Trong hầu hết các trường hợp, quyền sở hữu rõ ràng: bạn biết chính xác biến nào sở hữu một giá trị nhất định. Tuy nhiên, có những trường hợp một giá trị có thể có nhiều chủ sở hữu. Ví dụ, trong các cấu trúc dữ liệu đồ thị, nhiều cạnh có thể trỏ đến cùng một nút, và nút đó về mặt khái niệm được sở hữu bởi tất cả các cạnh trỏ tới nó. Một nút không nên bị dọn dẹp trừ khi không còn cạnh nào trỏ tới nó và do đó không còn chủ sở hữu.</p>
<p>Bạn phải cho phép sở hữu nhiều chủ sở hữu một cách rõ ràng bằng cách sử dụng kiểu Rust <code>Rc&lt;T&gt;</code>, viết tắt của <em>reference counting</em> (đếm tham chiếu). Kiểu <code>Rc&lt;T&gt;</code> theo dõi số lượng tham chiếu tới một giá trị để xác định xem giá trị đó còn đang được sử dụng hay không. Nếu không còn tham chiếu nào tới giá trị, giá trị có thể được dọn dẹp mà không làm invalid bất kỳ tham chiếu nào.</p>
<p>Hãy tưởng tượng <code>Rc&lt;T&gt;</code> giống như một TV trong phòng khách gia đình. Khi một người vào xem TV, họ bật TV lên. Những người khác có thể vào phòng và xem TV. Khi người cuối cùng rời phòng, họ tắt TV vì TV không còn được sử dụng nữa. Nếu ai đó tắt TV trong khi những người khác vẫn đang xem, sẽ có sự phản đối từ những người còn lại!</p>
<p>Chúng ta sử dụng kiểu <code>Rc&lt;T&gt;</code> khi muốn cấp phát dữ liệu trên heap để nhiều phần của chương trình đọc và không thể xác định tại thời điểm biên dịch phần nào sẽ sử dụng dữ liệu xong trước. Nếu biết phần nào sử dụng xong cuối cùng, chúng ta có thể chỉ định phần đó làm chủ sở hữu dữ liệu, và các quy tắc ownership thông thường được kiểm tra tại thời điểm biên dịch sẽ có hiệu lực.</p>
<p>Lưu ý rằng <code>Rc&lt;T&gt;</code> chỉ dùng trong các tình huống đơn luồng. Khi thảo luận về đa luồng trong Chương 16, chúng ta sẽ đề cập cách đếm tham chiếu trong các chương trình đa luồng.</p>
<h3 id="sử-dụng-rct-để-chia-sẻ-dữ-liệu"><a class="header" href="#sử-dụng-rct-để-chia-sẻ-dữ-liệu">Sử dụng <code>Rc&lt;T&gt;</code> để Chia Sẻ Dữ Liệu</a></h3>
<p>Hãy quay lại ví dụ danh sách cons trong Listing 15-5. Nhớ rằng chúng ta đã định nghĩa nó sử dụng <code>Box&lt;T&gt;</code>. Lần này, chúng ta sẽ tạo hai danh sách cùng chia sẻ quyền sở hữu của một danh sách thứ ba. Về mặt khái niệm, điều này tương tự như Hình 15-3:</p>
<img alt="Hai danh sách chia sẻ quyền sở hữu của danh sách thứ ba" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Hình 15-3: Hai danh sách, <code>b</code> và <code>c</code>, cùng chia sẻ quyền sở hữu của danh sách thứ ba, <code>a</code></span></p>
<p>Chúng ta sẽ tạo danh sách <code>a</code> chứa các giá trị 5 và 10. Sau đó, tạo thêm hai danh sách: <code>b</code> bắt đầu với 3 và <code>c</code> bắt đầu với 4. Cả hai danh sách <code>b</code> và <code>c</code> sau đó sẽ tiếp nối danh sách <code>a</code> ban đầu chứa 5 và 10. Nói cách khác, cả hai danh sách sẽ cùng chia sẻ danh sách đầu tiên chứa 5 và 10.</p>
<p>Cố gắng thực hiện kịch bản này sử dụng định nghĩa <code>List</code> với <code>Box&lt;T&gt;</code> sẽ không hoạt động, như được minh họa trong Listing 15-17:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<p><span class="caption">Listing 15-17: Minh họa việc không được phép có hai danh sách sử dụng <code>Box&lt;T&gt;</code> mà cố gắng chia sẻ quyền sở hữu của một danh sách thứ ba</span></p>
<p>Khi biên dịch mã này, chúng ta nhận được lỗi sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>Các biến thể <code>Cons</code> sở hữu dữ liệu mà chúng giữ, vì vậy khi chúng ta tạo danh sách <code>b</code>, <code>a</code> sẽ bị <strong>di chuyển</strong> vào <code>b</code> và <code>b</code> sở hữu <code>a</code>. Sau đó, khi chúng ta cố gắng sử dụng lại <code>a</code> để tạo <code>c</code>, điều đó không được phép vì <code>a</code> đã bị di chuyển.</p>
<p>Chúng ta có thể thay đổi định nghĩa của <code>Cons</code> để giữ các <strong>tham chiếu</strong> thay vì giá trị sở hữu, nhưng khi đó chúng ta phải khai báo các tham số <strong>lifetime</strong>. Khi khai báo lifetime, chúng ta sẽ chỉ định rằng mỗi phần tử trong danh sách sẽ sống ít nhất bằng toàn bộ thời gian sống của danh sách. Điều này đúng với các phần tử và danh sách trong Listing 15-17, nhưng không phải trong mọi trường hợp.</p>
<p>Thay vào đó, chúng ta sẽ thay đổi định nghĩa của <code>List</code> để sử dụng <code>Rc&lt;T&gt;</code> thay cho <code>Box&lt;T&gt;</code>, như được trình bày trong Listing 15-18. Mỗi biến thể <code>Cons</code> bây giờ sẽ giữ một giá trị và một <code>Rc&lt;T&gt;</code> trỏ tới một <code>List</code>. Khi tạo <code>b</code>, thay vì chiếm quyền sở hữu của <code>a</code>, chúng ta sẽ <strong>clone</strong> <code>Rc&lt;List&gt;</code> mà <code>a</code> giữ, từ đó tăng số lượng tham chiếu từ một lên hai và cho phép <code>a</code> và <code>b</code> cùng sở hữu dữ liệu trong <code>Rc&lt;List&gt;</code>. Chúng ta cũng sẽ clone <code>a</code> khi tạo <code>c</code>, tăng số lượng tham chiếu từ hai lên ba. Mỗi khi gọi <code>Rc::clone</code>, bộ đếm tham chiếu tới dữ liệu bên trong <code>Rc&lt;List&gt;</code> sẽ tăng lên, và dữ liệu sẽ không bị giải phóng cho đến khi không còn tham chiếu nào tới nó.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listing 15-18: A definition of <code>List</code> that uses
<code>Rc&lt;T&gt;</code></span></p>
<p>Chúng ta cần thêm câu lệnh <code>use</code> để đưa <code>Rc&lt;T&gt;</code> vào phạm vi sử dụng vì nó không có trong prelude. Trong <code>main</code>, chúng ta tạo danh sách chứa 5 và 10 và lưu nó vào một <code>Rc&lt;List&gt;</code> mới trong <code>a</code>. Sau đó, khi tạo <code>b</code> và <code>c</code>, chúng ta gọi hàm <code>Rc::clone</code> và truyền một tham chiếu tới <code>Rc&lt;List&gt;</code> trong <code>a</code> làm đối số.</p>
<p>Chúng ta có thể gọi <code>a.clone()</code> thay vì <code>Rc::clone(&amp;a)</code>, nhưng quy ước của Rust là sử dụng <code>Rc::clone</code> trong trường hợp này. Việc triển khai <code>Rc::clone</code> không tạo một bản sao sâu của toàn bộ dữ liệu như hầu hết các kiểu dữ liệu khác triển khai <code>clone</code>. Lệnh gọi <code>Rc::clone</code> chỉ tăng bộ đếm tham chiếu, điều này tốn rất ít thời gian. Các bản sao sâu của dữ liệu có thể mất nhiều thời gian. Bằng cách sử dụng <code>Rc::clone</code> cho việc đếm tham chiếu, chúng ta có thể phân biệt rõ ràng giữa các bản sao sâu (deep-copy) và các bản sao chỉ tăng bộ đếm tham chiếu. Khi tìm kiếm vấn đề về hiệu năng trong mã, chúng ta chỉ cần xem xét các bản sao sâu và có thể bỏ qua các lệnh gọi tới <code>Rc::clone</code>.</p>
<h3 id="cloning-một-rct-làm-tăng-bộ-đếm-tham-chiếu"><a class="header" href="#cloning-một-rct-làm-tăng-bộ-đếm-tham-chiếu">Cloning một <code>Rc&lt;T&gt;</code> làm tăng bộ đếm tham chiếu</a></h3>
<p>Hãy thay đổi ví dụ đang hoạt động trong Listing 15-18 để có thể thấy được số lượng tham chiếu thay đổi khi chúng ta tạo và xóa các tham chiếu tới <code>Rc&lt;List&gt;</code> trong <code>a</code>.</p>
<p>Trong Listing 15-19, chúng ta sẽ thay đổi <code>main</code> để có một scope bên trong cho danh sách <code>c</code>; sau đó chúng ta có thể thấy số lượng tham chiếu thay đổi khi <code>c</code> ra khỏi phạm vi.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>// --snip--

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listing 15-19: In ra số lượng tham chiếu</span></p>
<p>Tại mỗi điểm trong chương trình mà số lượng tham chiếu thay đổi, chúng ta in ra số lượng tham chiếu, lấy được bằng cách gọi hàm <code>Rc::strong_count</code>. Hàm này được đặt tên là <code>strong_count</code> thay vì <code>count</code> vì kiểu <code>Rc&lt;T&gt;</code> cũng có <code>weak_count</code>; chúng ta sẽ tìm hiểu <code>weak_count</code> được dùng để làm gì trong phần <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">“Ngăn chặn chu kỳ tham chiếu: Chuyển một <code>Rc&lt;T&gt;</code> thành <code>Weak&lt;T&gt;</code>”</a><!-- ignore -->.</p>
<p>Mã này in ra kết quả sau:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Chúng ta có thể thấy rằng <code>Rc&lt;List&gt;</code> trong <code>a</code> ban đầu có số lượng tham chiếu là 1;
sau đó mỗi lần gọi <code>clone</code>, số lượng này tăng lên 1. Khi <code>c</code> ra khỏi phạm vi, số lượng giảm đi 1.
Chúng ta không cần gọi một hàm nào để giảm số lượng tham chiếu như khi phải gọi <code>Rc::clone</code>
để tăng số lượng tham chiếu: việc triển khai trait <code>Drop</code> sẽ tự động giảm số lượng tham chiếu khi một giá trị <code>Rc&lt;T&gt;</code> ra khỏi phạm vi.</p>
<p>Điều chúng ta không thấy trong ví dụ này là khi <code>b</code> và sau đó <code>a</code> ra khỏi phạm vi vào cuối <code>main</code>,
số lượng tham chiếu sẽ bằng 0, và <code>Rc&lt;List&gt;</code> được dọn dẹp hoàn toàn. Sử dụng <code>Rc&lt;T&gt;</code>
cho phép một giá trị có nhiều chủ sở hữu, và số lượng tham chiếu đảm bảo rằng giá trị
vẫn hợp lệ miễn là còn bất kỳ chủ sở hữu nào tồn tại.</p>
<p>Thông qua các tham chiếu không thay đổi, <code>Rc&lt;T&gt;</code> cho phép bạn chia sẻ dữ liệu giữa nhiều phần
của chương trình chỉ để đọc. Nếu <code>Rc&lt;T&gt;</code> cho phép bạn có nhiều tham chiếu thay đổi cũng như vậy,
bạn có thể vi phạm một trong các quy tắc mượn đã thảo luận trong Chương 4: nhiều lần mượn thay đổi
cùng một vị trí có thể gây ra race condition và dữ liệu không nhất quán.
Nhưng khả năng thay đổi dữ liệu là rất hữu ích! Trong phần tiếp theo, chúng ta sẽ thảo luận
về mẫu <em>interior mutability</em> và kiểu <code>RefCell&lt;T&gt;</code> mà bạn có thể sử dụng cùng với <code>Rc&lt;T&gt;</code> để làm việc với giới hạn không thay đổi này.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-03-drop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-03-drop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-05-interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
