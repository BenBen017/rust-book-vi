<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ownership là gì? - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a id="the-stack-and-the-heap"></a></p>
<h2 id="ownership-tính-sở-hữu-là-gì"><a class="header" href="#ownership-tính-sở-hữu-là-gì">Ownership (tính sở hữu) là gì?</a></h2>
<p><em>Ownership</em> là một tập các quy tắc phối hợp với nhau, định hình cách Rust quản lý
bộ nhớ. Tất cả các chương trình đều phải quản lý cách chúng sử dụng bộ nhớ máy
tính khi chạy. Một số ngôn ngữ có bộ dọn rác chạy định kỳ để giải phóng các phần
bộ nhớ không còn được dùng tới; trong các ngôn ngữ khác, chương trình phải xin
cấp phát hoặc giải phóng bộ nhớ một cách cụ thể. Rust dùng cách tiếp cận thứ ba:
bộ nhớ được quản lý thông qua một hệ thống sở hữu với một tập các quy tắc sẽ được
kiểm tra bởi trình biên dịch. Nếu bất kỳ quy tắc nào bị vi phạm, chương trình sẽ
không được dịch. Không có bất kỳ tính năng nào của ownership làm chậm chương trình
của bạn khi chạy.</p>
<p>Vì ownership là một khái niệm mới với nhiều lập trình viên, nó sẽ mất một thời
gian để làm quen. Tin tốt là càng có nhiều kinh nghiệm với Rust và các quy tắc
của hệ thống ownership, bạn càng thấy việc lập trình các code an toàn và hiệu quả
dễ dàng hơn. Vậy nên hãy cố lên!</p>
<p>Khi đã hiểu ownership, bạn sẽ có một nền tảng chắc chắn để hiểu các tính năng
vốn làm cho Rust trở nên độc nhất. Trong chương này bạn sẽ học về ownership
thông qua một số ví dụ tập trung vào một cấu trúc dữ liệu rất phổ biến: string.</p>
<section class="note" aria-role="note">
<h3 id="stack-và-heap"><a class="header" href="#stack-và-heap">Stack và Heap</a></h3>
<p>Nhiều ngôn ngữ lập trình không yêu cầu bạn phải nghĩ về stack và heap thường
xuyên. Nhưng với một ngôn ngữ lập trình hệ thống như Rust, việc một giá trị sẽ
được lưu trên stack hay trên heap ảnh hưởng tới cách ngôn ngữ xử lý cũng như
lý do bạn quyết định. Các phần của ownership sẽ được mô tả trong mối quan hệ
với stack và heap ở phần sau của chương này, ở đây chỉ là một giải thích
ngắn gọn để chuẩn bị.</p>
<p>Cả hai stack và heap đều là các phần của bộ nhớ mà chương trình của bạn có thể
sử dụng khi chạy, nhưng chúng được tổ chức theo những cách khác nhau. Stack lưu
trữ các giá trị theo thứ tự bạn đưa vào và lấy các giá trị ra theo thứ tự ngược
lại. Ta thường gọi là <em>last in, first out</em>. Hãy tưởng tượng một chồng đĩa: khi
bạn thêm đĩa, bạn sẽ đặt chúng lên trên cùng, và khi cần lấy một cái đĩa, bạn
sẽ lấy cái trên nhất. Bạn sẽ không bỏ vào hoặc lấy ra các đĩa ở giữa hay bên
dưới cùng. Thêm dữ liệu vào được gọi là <em>đẩy (push)</em> và stack, và thao tác
lấy ra được gọi là <em>lấy ra khỏi stack (pop)</em>. Tất cả dữ liệu lưu trên stack
phải có một kiểu dữ liệu có kích thước cố định cho trước. Dữ liệu có kích thước
không thể biết trước khi biên dịch hoặc có thể thay đổi phải được lưu trên heap.</p>
<p>Heap được tổ chức ít quy củ hơn: khi bạn đưa dữ liệu lên heap, bạn yêu cầu một
không gian trống có kích thước cụ thể. Bộ phân phối bộ nhớ sẽ tìm một phần trống
trên heap đủ lớn để chứa, đánh dấu nó đã được dùng, và trả về một <em>con trỏ (pointer)</em>,
chứa địa chỉ của vị trí phần bộ nhớ vừa được cấp phát. Quá trình này được gọi
là <em>phân phối bộ nhớ trên heap</em> và đôi khi được gọi ngắn gọn là <em>phân phối bộ nhớ</em>
(đẩy một giá trị vào stack không được coi là phân phối bộ nhớ). Vì con trỏ chứa
địa chỉ vùng nhớ có kích thước cố định và biết trước, nó có thể được lưu trong
stack, nhưng khi bạn cần lấy dữ liệu thực sự, bạn sẽ cần đi theo địa chỉ chứa
trong con trỏ. Hãy tưởng tượng khi đến một nhà hàng, bạn cho nhân viên biết
số người trong nhóm, họ sẽ tìm một bàn trống đủ cho nhóm của bạn và dẫn bạn đến
đó. Nếu một người trong nhóm đến muộn, họ có thể hỏi nơi bạn ngồi để tìm bạn.</p>
<p>Đẩy một giá trị vào stack nhanh hơn phân phối trên heap vì trình quản lý không
cần tìm một nơi để lưu dữ liệu; vị trí đó luôn nằm trên đỉnh của stack. Trong khi
đó, phân phối bộ nhớ trên heap cần nhiều thao tác hơn vì trình quản lý đầu tiên
phải tìm một không gian trống đủ lớn để chứa dữ liệu, sau đó làm các thao tác để
đánh dấu việc sử dụng không gian nhớ đó.</p>
<p>Truy cập dữ liệu trên heap cũng chậm hơn trong stack vì bạn phải theo một con trỏ để
đến đúng nơi. Các bộ xử lý hiện nay sẽ hoạt động nhanh hơn nếu chúng không phải
truy cập bộ nhớ nhiều. Tiếp tục với ví dụ ở trên, hãy tưởng tượng một người phục
vụ ở nhà hàng phải nhận đặt món từ nhiều bàn khác nhau. Cách làm hiệu quả nhất là
nhận tất cả yêu cầu đặt món từ một bàn trước khi di chuyển đến bàn tiếp theo. Nhận
món từ bàn A, rồi sang bàn B, sau đó quay lại bàn A, rồi tiếp tục quay lại bàn B
có lẽ sẽ chậm hơn nhiều. Theo cùng cách, một bộ xử lý có thể hoàn thành công việc
tốt hơn nếu nó làm việc với các dữ liệu nằm gần nhau (giống như trong stack) hơn
là khi chúng nằm xa nhau (như với heap).</p>
<p>Khi code của bạn gọi một hàm, các giá trị truyền vào cho hàm đó (có thể bao gồm
cả các con trỏ lên heap) và các biến cục bộ của hàm đều được đẩy vào stack. Khi
hàm kết thúc, các giá trị đó sẽ được lấy ra khỏi stack.</p>
<p>Theo dõi phần code nào code đang dùng những phần nào của heap, tối thiểu hóa việc
trùng lắp dữ liệu, và dọn dẹp những dữ liệu nào không được dùng tới trên heap sao
cho chúng ta không cạn kiệt các tài nguyên bộ nhớ là những vấn đề mà ownership
nhắm đến. Một khi đã hiểu về ownership, bạn sẽ không cần nghĩ về stack và heap thường
xuyên nữa, nhưng biết mục đích chính của ownership là để quản lý bộ nhớ heap có thể
giúp giải thích vì sao nó làm việc theo cách mà bạn sẽ thấy.</p>
</section>
<h3 id="các-quy-tắc-của-ownership"><a class="header" href="#các-quy-tắc-của-ownership">Các quy tắc của Ownership</a></h3>
<p>Đầu tiên, hãy xem qua các quy tắc của ownership. Hãy ghi nhớ các quy tắc này khi
ta đi qua các ví đụ minh họa:</p>
<ul>
<li>Mỗi giá trị trong Rust có một chủ sở hữu (<em>owner</em>)</li>
<li>Mỗi thời điểm chỉ có duy nhất một owner.</li>
<li>Khi owner ra khỏi phạm vi (scope, tầm vực của biến) của nó, giá trị sẽ bị hủy.</li>
</ul>
<h3 id="tầm-vực-của-biến"><a class="header" href="#tầm-vực-của-biến">Tầm vực của biến</a></h3>
<p>Giờ ta đã hoàn thành cú pháp cơ bản của Rust, chúng ta sẽ không cần thêm <code>fn main() {</code>
vào các ví dụ, do vậy nếu muốn chạy thử hãy tự thêm chúng vào trong hàm <code>main</code>. Khi viết
các ví dụ theo cách ngắn gọn như vậy, chúng ta có thể tập trung vào chi tiết muốn
nói hơn là các đoạn code mẫu.</p>
<p>Ví dụ đầu tiên về ownership, chúng ta sẽ xem qua <em>tầm vực (scope)</em> của một số biến.
Một tầm vực là một đoạn trong một chương trình mà trong đó một thành phần nào đó
là hợp lệ. Hãy xem qua ví dụ sau:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>Biến <code>s</code> tham chiếu đến một giá trị chuỗi, giá trị này được hard code vào trong
phần text của chương trình. Các biến là hợp lệ tại thời điểm chúng được khai báo
cho đến hết <em>tầm vực</em> hiện tại. Listing 4-1 trình bày một chương trình với các
ghi chú chỉ ra nơi biến <code>s</code> là hợp lệ.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {                      // s is not valid here, since it's not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 4-1: Một biến và tầm vực (phạm vi) của nó</span></p>
<p>Nói cách khác, có hai thời điểm quan trọng ở đây:</p>
<ul>
<li>Khi <code>s</code> đi vào trong tầm vực, nó trở nên hợp lệ.</li>
<li><code>s</code> sẽ vẫn hợp lệ cho đến khi nó đi ra khỏi <em>tầm vực</em>.</li>
</ul>
<p>Tại điểm này, mối quan hệ giữa các tầm vực và khi các biến là hợp lệ hoàn toàn tương
tự trong các ngôn ngữ lập trình khác. Giờ chúng ta sẽ áp dụng điều này với kiểu
dữ liệu <code>String</code> để tìm hiểu sâu hơn.</p>
<h3 id="kiểu-string"><a class="header" href="#kiểu-string">Kiểu <code>String</code></a></h3>
<p>Để minh họa các quy tắc của ownership, chúng ta sẽ cần một kiểu dữ liệu phức tạp
hơn những kiểu đã được nói đến trong phần <a href="ch03-02-data-types.html#data-types">“Các kiểu dữ liệu”</a><!-- ignore -->
ở chương 3. Những kiểu được nói đến trong phần đó có kích thước cố định, có thể
được lưu trong stack và dễ dàng lấy ra khi đi ra khỏi phạm vi của nó, cũng như
có thể tạo một bản sao mới độc lập với bản gốc nếu một phần khác của chương trình
muốn đọc giá trị của nó. Nhưng chúng ta muốn xem cách dữ liệu được lưu trên heap
và khám phá cách Rust biết khi nào cần giải phóng dữ liệu đó, trong trường hợp
này <code>String</code> là một ví dụ tuyệt vời.</p>
<p>Chúng ta sẽ tập trung trên các phần của <code>String</code> có liên quan đến tính sở hữu (ownership).
Nhưng những phần này cũng có thể áp dụng lên các kiểu dữ liệu phức tạp khác,
bao gồm cả các kiểu trong thư viện chuẩn và các kiểu do bạn tự tạo. Chúng ta sẽ
nói sâu hơn về <code>String</code> trong <a href="ch08-02-strings.html">Chương 8</a><!-- ignore -->.</p>
<p>Chúng ta đã xem các giá trị chuỗi, khi mà các chuỗi được hard code vào thẳng
trong chương trình. Các giá trị chuỗi rất có ích, nhưng chúng lại không phù hợp
cho nhiều trường hợp. Một lý do là chúng không thể thay đổi. Một lý do khác là
trong nhiều trường hợp ta không biết giá trị thực sự của nó lúc viết code: ví
dụ nếu bạn muốn nhận dữ liệu từ người dùng và lưu lại? Với những trường hợp như
vậy, Rust có một kiểu dữ liệu chuỗi nữa, <code>String</code>. Kiểu dữ liệu này quản lý dữ liệu
được phân bố trên heap và nó có khả năng lưu trữ một khối văn bản ta không biết
vào thời điểm biên dịch. Bạn có thể tạo một <code>String</code> từ một giá trị chuỗi bằng cách
dùng hàm <code>from</code>, giống như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>Cặp dấu hai chấm <code>::</code> cho phép chúng ta đặt các thành phần trong Rust vào các
namespace khác nhau. Chúng ta có thể chỉ ra hàm <code>from</code> nằm trong <code>String</code> thay vì
phải viết theo kiểu <code>string_from</code>. Chúng ta sẽ thảo luận thêm về cú pháp này trong phần
<a href="ch05-03-method-syntax.html#method-syntax">“Cú pháp của phương thức”</a><!-- ignore --> ở chương 5. Và khi chúng
ta nói về namespace với các module trong <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the
Module Tree”</a><!-- ignore --> ở chương 7.</p>
<p>Kiểu chuỗi này <em>có thể</em> thay đổi.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // this will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>Vậy sự khác biệt ở đây là gì? Tại sao <code>String</code> có thể thay đổi mà hằng chuỗi thì
không? Sự khác nhau nằm ở cách hai loại này thao tác với bộ nhớ.</p>
<h3 id="bộ-nhớ-và-phân-phối-bộ-nhớ"><a class="header" href="#bộ-nhớ-và-phân-phối-bộ-nhớ">Bộ nhớ và phân phối bộ nhớ</a></h3>
<p>Trong trường hợp của hằng chuỗi, chúng ta biết nội dung của nó vào lúc biên dịch,
so vậy nội dung văn bản của nó sẽ được biên dịch thẳng vào bên trong file thực thi.
Đây là lý do vì sao các hằng chuỗi nhanh và hiệu quả. Nhưng những tính chất đó chỉ
có nhờ vào tính không-khả-biến (không thể thay đổi) của hằng chuỗi. Không may là,
bạn không thể nhúng một khối văn bản vào một file thực thi mà không biết kích thước
của nó vào lúc biên dịch, hoặc kích thước đó có thể thay đổi vào lúc chạy chương
trình.</p>
<p>Với kiểu <code>String</code>, để cho phép thay đổi nội dung, hoặc tăng độ dài của khối văn
bản, chúng ta cần phân phối cho nó một phần bộ nhớ trên heap để lưu trữ nội dung.
Điều này có nghĩa là:</p>
<ul>
<li>Phần bộ nhớ này cần được cấp pháp bởi trình quản lý bộ nhớ khi chạy chương trình.</li>
<li>Cần một cách để trả lại phần bộ nhớ này khi đã làm việc xong với chuỗi
<code>String</code> của chúng ta.</li>
</ul>
<p>Phần thứ nhất đã được hoàn thành khi chúng ta gọi <code>String::from</code>, hàm <code>from</code> sẽ
yêu cầu phần bộ nhớ mà nó cần. Những thao táo quen thuộc này khá phổ biến trong
các ngôn ngữ lập trình.</p>
<p>Tuy nhiên, phần thứ hai lại khác. Trong các ngôn ngữ có <em>bộ dọn rác</em> (garbage collector
(GC)), GC sẽ theo dõi và giải phóng các phần bộ nhớ không còn được dùng đến, và
ta không cần phải quan tâm đến chúng. Trong hầu hết các ngôn ngữ không có GC,
chúng ta phải có trách nhiệm tự quản lý các vùng nhớ để biết chúng khi nào không
còn được dùng nữa và gọi hàm giải phóng bộ nhớ. Công việc này vốn đã được lịch sử
chứng minh là rất khó để làm một các đúng đắn. Nếu ta lỡ quên, chúng ta sẽ gây lãng
phí bộ nhớ. Nếu ta làm điều đó quá sớm, chúng ta sẽ có một biến không hợp lệ. Nếu
ta làm điều đó hai lần, đó cũng là lỗi. Chúng ta phải có chính xác từng <code>free</code> cho
mỗi <code>allocate</code>.</p>
<p>Rust chọn một con đường khác: phần bộ nhớ sẽ được tự động trả lại một khi biến đi
ra khỏi tầm vực của nó. Đây là một phiên bản của ví dụ về tầm vực từ Listing 4-1
nhưng sử dụng <code>String</code> thay vì một hằng chuỗi:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}</span></code></pre></pre>
<p>Có một thời điểm tự nhiên mà chúng ta có thể trả lại phần bộ nhớ mà biến <code>String</code>
cần: khi <code>s</code> đi ra khỏi tầm vực của nó. Khi một biến đi ra khỏi scope, Rust gọi một
hàm đặc biệt cho chúng ta. Hàm này được gọi là <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, và
nó là nơi tác giả của <code>String</code> có thể viết code để trả lại phần bộ nhớ đã cấp phát
trước đó. Rust gọi <code>drop</code> một cách tự động ngay tại vị trí dấu ngoặc nhọn đóng.</p>
<blockquote>
<p>Ghi chú: trong C++, mẫu thiết kế cho phép tự động giải phóng tài nguyên vào
thời điểm một phần tử nào đó kết thúc vòng đời đôi khi được gọi là: <em>Resource
Acquisition Is Initialization (RAII)</em>. Hàm <code>drop</code> trong Rust sẽ là quen thuộc
nếu bạn đã từng sử dụng mẫu RAII.</p>
</blockquote>
<p>Mẫu thiết kế này có một sự ảnh hưởng sâu sắc đến cách viết code Rust. Nó trông
có vẻ đơn giản, nhưng trong những trường hợp phức tạp code có thể trở nên khó dự
đoán, như khi ta có nhiều biến dùng dữ liệu được phân bố trên heap. Hãy cùng khảo
sát một vài trường hợp:</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a><a id="variables-and-data-interacting-with-move"></a></p>
<h4 id="các-biến-và-việc-tương-tác-dữ-liệu-với-move"><a class="header" href="#các-biến-và-việc-tương-tác-dữ-liệu-với-move">Các biến và việc tương tác dữ liệu với Move</a></h4>
<p>Nhiều biến có thể tương tác với cùng dữ liệu theo những cách khác nhau trong Rust.
Hãy cùng xem qua một ví dụ sử dụng biến kiểu integer trong Listing 4-2.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 4-2: Gán một số nguyên từ biến <code>x</code> sang biến <code>y</code></span></p>
<p>Chúng ta có thể đoán xem đoạn code này làm gì: “gán giá trị <code>5</code> vào <code>x</code>; sau đó
tạo một bản sao của giá trị trong <code>x</code> và gán nó cho <code>y</code>”. Chúng ta sẽ có hai biến,
<code>x</code> và <code>y</code>, và cả hai đều bằng <code>5</code>. Đây thực sự là những gì đã diễn ra, vì số nguyên
là những giá trị đơn giản với kích thước cố định biết trước, và hai giá trị <code>5</code> đó
sẽ được lưu trữ trên stack.</p>
<p>Giờ hãy xem qua phiên bản với <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Đoạn này trông khá tương tự, do vậy ta có thể cho là chúng hoạt động theo cùng cách:
đó là, dòng thứ hai sẽ tạo một bản sao của giá trị trong <code>s1</code> và gán nó vào cho
<code>s2</code>. Nhưng đây không thực sự là điều diễn ra.</p>
<p>Hãy xem qua Figure 4-1 để xem điều gì diễn ra đằng sau đối với <code>String</code>. Một
<code>String</code> được tạo nên từ ba phần, được hiển thị phía bên trái: một con trỏ
đến phần bộ nhớ lưu giữ nội dung của chuỗi, một biến chứa chiều dài và một chứa
khả năng lưu trữ. Nhóm dữ liệu này được lưu trên stack. Bên phía phải là phần bộ
nhớ chứa nội dung của chuỗi.</p>
<p><img alt="Hai bảng: Bảng đầu tiên chứa biểu diễn của s1 trên stack, bao gồm chiều 
dài (5), dung lượng khả dụng (5) và một con trỏ đến giá trị đầu tiên trong bảng thứ
hai. Bảng thứ hai chứa biểu diễn dữ liệu của chuỗi trên heap, theo từng byte."
src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Figure 4-1: Biểu diễn bên trong bộ nhớ của một <code>String</code>
chứa giá trị <code>"hello"</code> gán cho biến <code>s1</code></span></p>
<p>Chiều dài là bao nhiêu bộ nhớ, tính theo byte, mà nội dung của <code>String</code> hiện đang
dùng. Dung lượng khả dụng là tổng số bộ nhớ, tính theo byte, mà <code>String</code> đã nhận
từ trình quản lý bộ nhớ. Sự khác nhau giữa chiều dài và dung lượng khả dụng, vì
không có trong ví dụ này, nên hiện tại ta tạm thời bỏ qua không nói đến.</p>
<p>Khi ta gán <code>s1</code> vào <code>s2</code>, nội dung của <code>String</code> sẽ được sao chép, có nghĩa là ta
chỉ sao chép các thông tin con trỏ, chiều dài, và dung lượng khả dụng vốn được
lưu trên stack. Ta không sao chép dữ liệu trên heap mà con trỏ trỏ đến. Nói cách
khác, biểu diễn dữ liệu trong bộ nhớ sẽ giống như trong hình minh họa 4-2.</p>
<p><img alt="Ba bảng: bảng s1 và s2 biểu diễn các string tương ứng trên stack, và 
cả hai cùng trỏ vào cùng một vùng dữ liệu trên heap."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Hình minh họa 4-2: Biểu diễn trong bộ nhớ của biến <code>s2</code>
chứa bản sao con trỏ, chiều dài, và dung lượng khả dụng <code>s1</code></span></p>
<p>Biểu diễn <em>không</em> trông giống như Hình 4-3, là tổ chức bộ nhớ trong trường hợp Rust
cũng sao chép dữ liệu heap. Nếu Rust đã làm điều này, phép gán <code>s2 = s1</code> có thể
rất tốn kém về hiệu suất thời gian chạy nếu dữ liệu trên heap lớn.</p>
<p><img alt="Bốn bảng: hai bảng đại diện cho dữ liệu stack cho s1 và s2,
và mỗi con trỏ trỏ đến bản sao dữ liệu chuỗi của riêng nó trên heap."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Hình 4-3: Biểu diễn bộ nhớ sau phép gán <code>s2 = s1</code> nếu Rust
sao chép cả dữ liệu trên heap</span></p>
<p>Trước đó, chúng tôi đã nói rằng khi một biến ra ngoài phạm vi, Rust sẽ tự động
gọi hàm <code>drop</code> và dọn sạch bộ nhớ heap cho biến đó. Nhưng Hình 4-2 cho thấy cả
hai con trỏ dữ liệu trỏ đến cùng một vị trí. Đây là một vấn đề: khi <code>s2</code> và <code>s1</code>
vượt ra ngoài phạm vi, cả hai sẽ cố gắng giải phóng cùng một phần bộ nhớ. Đây
được gọi là lỗi <em>double free</em> (giải phóng hai lần) và là một trong những lỗi
lỗi an toàn bộ nhớ mà chúng ta đã đề cập đến trước đây. Giải phóng bộ nhớ
hai lần có thể dẫn đến sai sót trong tổ chức bộ nhớ, và có khả năng dẫn đến
các lỗ hổng bảo mật.</p>
<p>Để đảm bảo an toàn cho bộ nhớ, sau dòng <code>let s2 = s1;</code>, Rust coi <code>s1</code> là
không còn giá trị. Do đó, Rust không cần giải phóng bất cứ thứ gì khi <code>s1</code> ra
ra khỏi phạm vi. Xem điều gì sẽ xảy ra khi bạn cố gắng sử dụng <code>s1</code> sau khi <code>s2</code>
được tạo; nó sẽ không hoạt động:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>Bạn sẽ gặp lỗi như thế này vì Rust ngăn bạn sử dụng tham chiếu không hợp lệ:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Nếu bạn đã nghe các thuật ngữ <em>shallow copy</em> (sao chép cạn) và <em>deep copy</em>
(sao chép sâu) khi làm việc với các ngôn ngữ khác, việc sao chép con trỏ,
độ dài và dung lượng mà không sao chép dữ liệu có thể giống như tạo một
shallow copy. Nhưng vì Rust cũng vô hiệu hóa biến đầu tiên, thay vì được gọi là
bản sao nông, nó được gọi là <em>move</em> (di chuyển). Trong ví dụ này, chúng ta
sẽ nói rằng <code>s1</code> đã được <em>move</em> vào <code>s2</code>. Vì vậy, những gì thực sự xảy ra
được thể hiện trong Hình 4-4.</p>
<p><img alt="Ba bảng: bảng s1 và s2 đại diện cho các chuỗi đó trên
stack tương ứng và cả hai đều trỏ đến cùng một dữ liệu chuỗi trên heap.
Bảng s1 chuyển sang màu xám vì s1 không còn giá trị; chỉ s2 có thể được sử dụng để
truy cập dữ liệu heap." src="img/trpl04-04.svg" class="center" style="width:
50%;" /></p>
<p><span class="caption">Hình 4-4: Biểu diễn trong bộ nhớ sau khi <code>s1</code> được
vô hiệu</span></p>
<p>Điều này giúp giải quyết vấn đề của chúng ta! Với chỉ <code>s2</code> hợp lệ, khi vượt ra
phạm vi, chỉ có nó phải giải phóng bộ nhớ, và chỉ vậy là đủ.</p>
<p>Ngoài ra, có một lựa chọn thiết kế được ngụ ý bởi điều này: Rust sẽ không bao giờ
tự động tạo các bản sao dữ liệu “sâu” của bạn. Do đó, bất kỳ thao tác <em>tự động</em>
sao chép đều có thể được coi là không tốn kém về hiệu suất hoạt động.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="các-biến-và-tương-tác-dữ-liệu-với-clone"><a class="header" href="#các-biến-và-tương-tác-dữ-liệu-với-clone">Các biến và tương tác dữ liệu với Clone</a></h4>
<p>Nếu chúng tôi <em>thực sự</em> muốn sao chép cả dữ liệu trên heap của <code>String</code>, không chỉ
dữ liệu trên stack, chúng ta có thể sử dụng một phương pháp phổ biến gọi là <code>clone</code> (nhân bản).
Chúng ta sẽ thảo luận về cú pháp trong Chương 5, nhưng bởi vì các phương thức kiểu này
là một tính năng phổ biến trong nhiều ngôn ngữ lập trình, bạn có thể đã nhìn thấy chúng trước đây.</p>
<p>Đây là một ví dụ về phương thức <code>clone</code> đang hoạt động:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>Cách này hoạt động hoàn toàn tốt và tạo ra hành vi như trong Hình 4-3,
khi mà dữ liệu trên heap <em>thực sự</em> được sao chép.</p>
<p>Khi bạn thấy lệnh gọi đến <code>clone</code>, bạn sẽ biết rằng một số code tùy biến đang được
được thực hiện và code đó có thể tốn kém. Đó cũng là một chỉ dẫn trực quan cho thấy
rằng một điều gì đó khác đang diễn ra.</p>
<p><a id="stack-only-data-copy"></a></p>
<h4 id="dữ-liệu-trên-stack-sao-chép"><a class="header" href="#dữ-liệu-trên-stack-sao-chép">Dữ liệu trên stack: sao chép</a></h4>
<p>Có một điều thắc mắc khác mà chúng ta chưa nói đến. Mã này sử dụng
integer — là một phần được hiển thị trong trong Listing 4-2 — chạy được và
hoàn toàn hợp lệ:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>Nhưng mã này dường như mâu thuẫn với những gì chúng ta vừa học được: chúng ta không có lời gọi đến
<code>clone</code>, nhưng <code>x</code> vẫn hợp lệ và không được chuyển vào <code>y</code>.</p>
<p>Rust có một annotation (chú thích) đặc biệt gọi là <code>Copy</code> mà chúng ta có thể đặt trên
các loại dữ liệu được lưu trữ trên stack, như số nguyên (chúng ta sẽ nói thêm về
annotation trong <a href="ch10-02-traits.html">Chương 10</a><!-- ignore -->). Nếu một kiểu dữ liệu áp dụng
<code>Copy</code>, các biến sử dụng nó không move mà được copy một cách bình thường,
làm cho chúng vẫn hợp lệ sau khi được gán cho một biến khác.</p>
<p>Rust sẽ không cho phép chúng ta đánh dấu một kiểu bằng <code>Copy</code> nếu kiểu đó hoặc
bất kỳ thành phần nào của nó, đã được đánh dấu <code>Drop</code>. Nếu kiểu dữ liệu cần làm một
điều gì đó đặc biệt khi giá trị vượt quá phạm vi và chúng ta thêm chú thích <code>Copy</code>
cho loại đó, chúng tôi sẽ gặp lỗi biên dịch. Để tìm hiểu về cách thêm chú thích <code>Copy</code>
vào kiểu dữ liệu của bạn để thực hiện trait, xem phần <a href="appendix-03-derivable-traits.html">“Derivable Traits”</a><!-- ignore -->
trong Phụ lục C.</p>
<p>Vậy, những kiểu dữ liệu nào thực hiện đặc điểm <code>Copy</code>? Để chắc chắn bạn có thể
kiểm tra tài liệu của loại dữ liệu đó, nhưng theo nguyên tắc chung, bất kỳ nhóm kiểu dữ liệu
vô hướng đơn giản nào các giá trị có thể triển khai <code>Copy</code> và không có gì yêu cầu phân bổ hoặc là một số
dạng tài nguyên có thể triển khai <code>Copy</code>. Đây là một số loại áp dụng <code>Copy</code>:</p>
<ul>
<li>Tất cả các loại số nguyên, chẳng hạn như <code>u32</code>.</li>
<li>Kiểu Boolean, <code>bool</code>, với các giá trị <code>true</code> và <code>false</code>.</li>
<li>Tất cả các loại dấu phẩy động, chẳng hạn như <code>f64</code>.</li>
<li>Loại ký tự, <code>char</code>.</li>
<li>Tuple, nếu chúng chỉ chứa các loại cũng áp dụng <code>Copy</code>. Ví dụ,
<code>(i32, i32)</code> thực hiện <code>Copy</code>, nhưng <code>(i32, String)</code> thì không.</li>
</ul>
<p><a id="ownership-and-functions"></a></p>
<h3 id="ownership-và-functions"><a class="header" href="#ownership-và-functions">Ownership và Functions</a></h3>
<p>Cơ chế chuyển một giá trị cho một hàm cũng tương tự như khi gán giá trị cho một biến.
Truyền một biến cho một hàm sẽ move hoặc copy, giống như phép gán. Liệt kê 4-3 có một ví
dụ với một số annotation nơi các biến vào và ra khỏi phạm vi.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // Because i32 implements the Copy trait,
                                    // x does NOT move into the function,
                                    // so it's okay to use x afterward.

} // Here, x goes out of scope, then s. However, because s's value was moved,
  // nothing special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{some_string}");
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{some_integer}");
} // Here, some_integer goes out of scope. Nothing special happens.</code></pre></pre>
<p><span class="caption">Liệt kê 4-3: Các hàm với ownership và scope
annotated</span></p>
<p>Nếu chúng tôi cố sử dụng <code>s</code> sau lệnh gọi <code>takes_ownership</code>, Rust sẽ đưa ra một
lỗi biên dịch. Những kiểm tra tĩnh này bảo vệ chúng ta khỏi những sai lầm. Thử thêm
code vào <code>main</code> để sử dụng <code>s</code> và <code>x</code> và xem bạn có thể sử dụng chúng ở đâu và ở đâu
các quy tắc ownership ngăn cản bạn làm vậy.</p>
<p><a id="return-values-and-scope"></a></p>
<h3 id="giá-trị-trả-về-và-scope"><a class="header" href="#giá-trị-trả-về-và-scope">Giá trị trả về và Scope</a></h3>
<p>Các giá trị trả về cũng có thể chuyển ownership. Liệt kê 4-4 trình bày một ví dụ về một
hàm trả về một số giá trị, với các annotation tương tự như trong Liệt kê 4-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = gives_ownership();        // gives_ownership moves its return
                                       // value into s1

    let s2 = String::from("hello");    // s2 comes into scope

    let s3 = takes_and_gives_back(s2); // s2 is moved into
                                       // takes_and_gives_back, which also
                                       // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {       // gives_ownership will move its
                                       // return value into the function
                                       // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                        // some_string is returned and
                                       // moves out to the calling
                                       // function
}

// This function takes a String and returns a String.
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string comes into
    // scope

    a_string  // a_string is returned and moves out to the calling function
}</code></pre></pre>
<p><span class="caption">Listing 4-4: Chuyển ownership của các giá trị trả về</span></p>
<p>Ownership của một biến luôn tuân theo cùng một khuôn mẫu: việc gán giá trị cho một
biến khác sẽ move nó. Khi một biến bao gồm dữ liệu trên heap nằm ngoài scope, giá trị
sẽ bị <code>drop</code> trừ khi ownership đã được chuyển sang một biến khác.</p>
<p>Khi điều này hoạt động, việc lấy ownership và sau đó trả lại ownership với các
hàm sẽ có một chút tẻ nhạt. Điều gì sẽ xảy ra nếu chúng ta muốn để một hàm sử dụng một
giá trị nhưng không lấy ownership? Thật khó chịu khi bất cứ thứ gì chúng ta truyền đi
cũng cần phải được trả lại nếu chúng ta muốn sử dụng lại, chưa kể chúng ta còn phải trả
về giá trị của hàm.</p>
<p>Rust cho phép chúng ta trả về nhiều giá trị bằng cách sử dụng tuple, như trong Liệt kê 4-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre></pre>
<p><span class="caption">Liệt kê 4-5: Trả về ownership của các tham số</span></p>
<p>Nhưng quả là có quá nhiều thứ cho một khái niệm vốn khá phổ biến. Thật may mắn cho chúng ta,
Rust có một tính năng cho phép sử dụng một giá trị mà không cần
chuyển quyền sở hữu, được gọi là <em>reference</em> (tham chiếu).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
