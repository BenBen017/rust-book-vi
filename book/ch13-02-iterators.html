<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Processing a Series of Items with Iterators - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="xử-lý-một-chuỗi-phần-tử-với-iterators"><a class="header" href="#xử-lý-một-chuỗi-phần-tử-với-iterators">Xử Lý Một Chuỗi Phần Tử với Iterators</a></h2>
<p>Mẫu iterator cho phép bạn thực hiện một tác vụ nào đó trên một chuỗi
các phần tử lần lượt. Một iterator chịu trách nhiệm về logic lặp qua
từng phần tử và xác định khi nào chuỗi kết thúc. Khi sử dụng iterators,
bạn không cần tự triển khai lại logic đó.</p>
<p>Trong Rust, iterators là <em>lazy</em>, nghĩa là chúng không có tác dụng gì
cho đến khi bạn gọi các phương thức tiêu thụ iterator để dùng hết nó.
Ví dụ, đoạn code trong Listing 13-10 tạo một iterator trên các phần
tử trong vector <code>v1</code> bằng cách gọi phương thức <code>iter</code> định nghĩa
trên <code>Vec&lt;T&gt;</code>. Đoạn code này tự nó không làm gì hữu ích.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-10: Tạo một iterator</span></p>
<p>Iterator được lưu trong biến <code>v1_iter</code>. Khi đã tạo một iterator, chúng
ta có thể sử dụng nó theo nhiều cách khác nhau. Trong Listing 3-5 ở
Chương 3, chúng ta đã lặp qua một mảng bằng vòng lặp <code>for</code> để thực
hiện một số code trên từng phần tử. Ngầm định, điều này đã tạo và
sau đó tiêu thụ một iterator, nhưng chúng ta đã bỏ qua cách thức
hoạt động chính xác của nó cho đến bây giờ.</p>
<p>Trong ví dụ ở Listing 13-11, chúng ta tách việc tạo iterator ra khỏi
việc sử dụng iterator trong vòng lặp <code>for</code>. Khi vòng lặp <code>for</code> được
gọi với iterator trong <code>v1_iter</code>, mỗi phần tử trong iterator được
sử dụng trong một lần lặp của vòng lặp, in ra từng giá trị.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-11: Sử dụng iterator trong vòng lặp <code>for</code></span></p>
<p>Trong các ngôn ngữ không có iterator được cung cấp bởi thư viện chuẩn,
bạn có thể viết chức năng tương tự bằng cách khởi tạo một biến ở
chỉ số 0, dùng biến đó để truy cập vào vector lấy giá trị, và tăng
giá trị biến trong một vòng lặp cho đến khi đạt tổng số phần tử
trong vector.</p>
<p>Iterators xử lý tất cả logic đó cho bạn, giảm bớt code lặp đi lặp
lại mà bạn có thể vô tình làm sai. Iterators cung cấp nhiều sự linh
hoạt hơn để sử dụng cùng một logic với nhiều loại chuỗi khác nhau,
không chỉ những cấu trúc dữ liệu có thể truy cập theo chỉ số như
vector. Hãy xem cách iterators thực hiện điều đó.</p>
<h3 id="trait-iterator-và-phương-thức-next"><a class="header" href="#trait-iterator-và-phương-thức-next">Trait <code>Iterator</code> và Phương Thức <code>next</code></a></h3>
<p>Tất cả iterators triển khai một trait có tên <code>Iterator</code> được định
nghĩa trong thư viện chuẩn. Định nghĩa của trait trông như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Lưu ý rằng định nghĩa này sử dụng một số cú pháp mới: <code>type Item</code> và
<code>Self::Item</code>, định nghĩa một <em>associated type</em> với trait này. Chúng ta
sẽ bàn kỹ về associated types trong Chương 19. Hiện tại, bạn chỉ cần
biết rằng đoạn code này nói rằng việc triển khai trait <code>Iterator</code> yêu
cầu bạn cũng phải định nghĩa một kiểu <code>Item</code>, và kiểu <code>Item</code> này được
sử dụng trong kiểu trả về của phương thức <code>next</code>. Nói cách khác, kiểu
<code>Item</code> sẽ là kiểu được trả về từ iterator.</p>
<p>Trait <code>Iterator</code> chỉ yêu cầu người triển khai định nghĩa một phương
thức: phương thức <code>next</code>, trả về từng phần tử của iterator một lần,
bao bọc trong <code>Some</code> và, khi kết thúc iteration, trả về <code>None</code>.</p>
<p>Chúng ta có thể gọi trực tiếp phương thức <code>next</code> trên iterators; Listing
13-12 minh họa các giá trị được trả về từ các lần gọi lặp đi lặp lại
<code>next</code> trên iterator được tạo từ vector.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-12: Gọi phương thức <code>next</code> trên một iterator</span></p>
<p>Lưu ý rằng chúng ta cần làm cho <code>v1_iter</code> có thể thay đổi (mutable):
gọi phương thức <code>next</code> trên một iterator thay đổi trạng thái nội bộ mà
iterator sử dụng để theo dõi vị trí hiện tại trong chuỗi. Nói cách
khác, đoạn code này <em>tiêu thụ</em>, hay dùng hết, iterator. Mỗi lần gọi
<code>next</code> lấy đi một phần tử từ iterator. Chúng ta không cần làm cho
<code>v1_iter</code> mutable khi sử dụng vòng lặp <code>for</code> vì vòng lặp lấy quyền
sở hữu của <code>v1_iter</code> và làm cho nó mutable ngầm.</p>
<p>Cũng lưu ý rằng các giá trị nhận được từ các lần gọi <code>next</code> là các
tham chiếu bất biến (immutable references) đến các giá trị trong
vector. Phương thức <code>iter</code> tạo ra một iterator trên các tham chiếu
bất biến. Nếu muốn tạo một iterator lấy quyền sở hữu của <code>v1</code> và
trả về các giá trị sở hữu, ta có thể gọi <code>into_iter</code> thay vì <code>iter</code>.
Tương tự, nếu muốn lặp qua các tham chiếu có thể thay đổi, ta có thể
gọi <code>iter_mut</code> thay vì <code>iter</code>.</p>
<h3 id="các-phương-thức-tiêu-thụ-iterator"><a class="header" href="#các-phương-thức-tiêu-thụ-iterator">Các phương thức tiêu thụ iterator</a></h3>
<p>Trait <code>Iterator</code> có một số phương thức khác nhau với triển khai mặc
định do thư viện chuẩn cung cấp; bạn có thể tìm hiểu về các phương
thức này bằng cách xem tài liệu API của trait <code>Iterator</code>. Một số phương
thức này gọi phương thức <code>next</code> trong định nghĩa của chúng, đó là lý
do bạn phải triển khai <code>next</code> khi implement trait <code>Iterator</code>.</p>
<p>Các phương thức gọi <code>next</code> được gọi là <em>consuming adaptors</em>, vì gọi
chúng sẽ tiêu thụ iterator. Một ví dụ là phương thức <code>sum</code>, nó
lấy quyền sở hữu iterator và lặp qua các phần tử bằng cách gọi
<code>next</code> liên tục, do đó tiêu thụ iterator. Khi lặp qua, nó cộng
mỗi phần tử vào tổng dồn và trả về tổng khi kết thúc iteration.
Listing 13-13 có một ví dụ minh họa việc sử dụng phương thức <code>sum</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-13: Gọi phương thức <code>sum</code> để lấy tổng
tất cả các phần tử trong iterator</span></p>
<p>Chúng ta không được phép sử dụng <code>v1_iter</code> sau khi gọi <code>sum</code> vì <code>sum</code>
lấy quyền sở hữu của iterator mà chúng ta gọi nó trên đó.</p>
<h3 id="các-phương-thức-tạo-ra-iterator-khác"><a class="header" href="#các-phương-thức-tạo-ra-iterator-khác">Các phương thức tạo ra iterator khác</a></h3>
<p><em>Iterator adaptors</em> là các phương thức định nghĩa trên trait <code>Iterator</code>
không tiêu thụ iterator. Thay vào đó, chúng tạo ra các iterator khác
bằng cách thay đổi một số khía cạnh của iterator gốc.</p>
<p>Listing 13-14 minh họa việc gọi phương thức iterator adaptor <code>map</code>,
nó nhận một closure để gọi trên từng phần tử khi các phần tử được
lặp qua. Phương thức <code>map</code> trả về một iterator mới tạo ra các phần
tử đã được sửa đổi. Closure ở đây tạo ra một iterator mới mà mỗi
phần tử từ vector sẽ được tăng thêm 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2024"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-14: Gọi iterator adaptor <code>map</code> để
tạo một iterator mới</span></p>
<p>Tuy nhiên, đoạn code này sinh ra một cảnh báo:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Đoạn code trong Listing 13-14 không làm gì cả; closure mà chúng
ta đã chỉ định chưa bao giờ được gọi. Cảnh báo nhắc nhở chúng
ta lý do: các iterator adaptors là lazy, và chúng ta cần tiêu
thụ iterator ở đây.</p>
<p>Để sửa cảnh báo này và tiêu thụ iterator, chúng ta sẽ sử dụng
phương thức <code>collect</code>, mà chúng ta đã dùng trong Chương 12 với
<code>env::args</code> trong Listing 12-1. Phương thức này tiêu thụ iterator
và thu thập các giá trị kết quả vào một kiểu dữ liệu collection.</p>
<p>Trong Listing 13-15, chúng ta thu thập kết quả của việc lặp qua
iterator được trả về từ cuộc gọi <code>map</code> vào một vector. Vector
này sẽ chứa từng phần tử từ vector gốc tăng thêm 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-15: Gọi phương thức <code>map</code> để tạo một
iterator mới và sau đó gọi phương thức <code>collect</code> để tiêu thụ iterator
mới và tạo ra một vector</span></p>
<p>Vì <code>map</code> nhận một closure, chúng ta có thể chỉ định bất kỳ thao tác
nào muốn thực hiện trên từng phần tử. Đây là một ví dụ tuyệt vời
về cách closures cho phép bạn tùy chỉnh hành vi trong khi tái sử dụng
hành vi lặp mà trait <code>Iterator</code> cung cấp.</p>
<p>Bạn có thể xâu chuỗi nhiều lần gọi các iterator adaptor để thực
hiện các hành động phức tạp một cách dễ đọc. Nhưng vì tất cả các
iterator là lazy, bạn phải gọi một trong các phương thức consuming
adaptor để nhận kết quả từ các cuộc gọi đến iterator adaptor.</p>
<h3 id="sử-dụng-closures-capture-environment"><a class="header" href="#sử-dụng-closures-capture-environment">Sử dụng Closures capture environment</a></h3>
<p>Nhiều iterator adaptor nhận closures làm tham số, và thường
các closures chúng ta chỉ định làm tham số cho iterator adaptor
sẽ là các closures capture environment của chúng.</p>
<p>Trong ví dụ này, chúng ta sẽ sử dụng phương thức <code>filter</code> nhận
một closure. Closure nhận một phần tử từ iterator và trả về
<code>bool</code>. Nếu closure trả về <code>true</code>, giá trị sẽ được bao gồm
trong iteration do <code>filter</code> tạo ra. Nếu closure trả về <code>false</code>,
giá trị sẽ không được bao gồm.</p>
<p>Trong Listing 13-16, chúng ta sử dụng <code>filter</code> với một closure
capture biến <code>shoe_size</code> từ môi trường của nó để lặp qua
một tập hợp các instance của struct <code>Shoe</code>. Nó chỉ trả về
những đôi giày có kích thước đã chỉ định.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Listing 13-16: Sử dụng phương thức <code>filter</code> với một
closure capture <code>shoe_size</code></span></p>
<p>Hàm <code>shoes_in_size</code> nhận quyền sở hữu một vector các đôi giày và một
kích thước giày làm tham số. Nó trả về một vector chỉ chứa các đôi
giày có kích thước đã chỉ định.</p>
<p>Trong thân hàm <code>shoes_in_size</code>, chúng ta gọi <code>into_iter</code> để tạo một
iterator lấy quyền sở hữu của vector. Sau đó, chúng ta gọi <code>filter</code>
để biến đổi iterator đó thành một iterator mới chỉ chứa các phần tử
mà closure trả về <code>true</code>.</p>
<p>Closure capture tham số <code>shoe_size</code> từ môi trường và so sánh giá trị
với kích thước của từng đôi giày, chỉ giữ lại những đôi có kích thước
được chỉ định. Cuối cùng, gọi <code>collect</code> thu thập các giá trị trả về
từ iterator đã được biến đổi vào một vector được hàm trả về.</p>
<p>Bài test cho thấy khi gọi <code>shoes_in_size</code>, chúng ta chỉ nhận lại
những đôi giày có cùng kích thước với giá trị đã chỉ định.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
