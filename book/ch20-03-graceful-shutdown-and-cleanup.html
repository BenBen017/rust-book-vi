<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Graceful Shutdown and Cleanup - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="tắt-và-dọn-dẹp-một-cách-Êm-ái"><a class="header" href="#tắt-và-dọn-dẹp-một-cách-Êm-ái">Tắt và Dọn dẹp Một cách Êm ái</a></h2>
<p>Code trong Listing 20-20 đang xử lý các request một cách bất đồng bộ thông qua
việc sử dụng thread pool, đúng như chúng ta mong muốn. Chúng ta nhận một số
cảnh báo về các trường <code>workers</code>, <code>id</code>, và <code>thread</code> mà chúng ta không sử dụng
trực tiếp, nhắc nhở rằng chúng ta chưa dọn dẹp gì cả. Khi sử dụng phương pháp
ít tinh tế hơn <span class="keystroke">ctrl-c</span> để dừng thread chính, tất
cả các thread khác cũng bị dừng ngay lập tức, ngay cả khi chúng đang xử lý một
request.</p>
<p>Tiếp theo, chúng ta sẽ triển khai trait <code>Drop</code> để gọi <code>join</code> trên từng thread trong pool
để chúng có thể hoàn tất các request mà chúng đang xử lý trước khi đóng. Sau đó,
chúng ta sẽ triển khai một cách để báo cho các thread biết rằng chúng nên ngừng
nhận request mới và tắt. Để xem code này hoạt động, chúng ta sẽ chỉnh sửa server
chỉ chấp nhận hai request trước khi tắt thread pool một cách êm ái.</p>
<h3 id="triển-khai-trait-drop-trên-threadpool"><a class="header" href="#triển-khai-trait-drop-trên-threadpool">Triển khai trait <code>Drop</code> trên <code>ThreadPool</code></a></h3>
<p>Hãy bắt đầu với việc triển khai <code>Drop</code> cho thread pool. Khi pool bị drop, tất cả
các thread của chúng ta nên join để đảm bảo chúng hoàn thành công việc. Listing 20-22
cho thấy một lần thử đầu tiên của việc triển khai <code>Drop</code>; code này vẫn chưa chạy được.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/listing-20-22/src/lib.rs:here}}</code></pre>
<p><span class="caption">Listing 20-22: Gọi <code>join</code> trên từng thread khi thread pool
ra khỏi phạm vi</span></p>
<p>Trước tiên, chúng ta lặp qua từng <code>worker</code> trong thread pool. Chúng ta sử dụng <code>&amp;mut</code>
vì <code>self</code> là một tham chiếu có thể thay đổi, và chúng ta cũng cần khả năng thay đổi
<code>worker</code>. Với mỗi worker, chúng ta in ra một thông báo nói rằng worker cụ thể này
đang tắt, sau đó gọi <code>join</code> trên thread của worker đó. Nếu việc gọi <code>join</code> thất bại,
chúng ta sử dụng <code>unwrap</code> để Rust panic và thực hiện một việc tắt không êm ái.</p>
<p>Dưới đây là lỗi mà chúng ta nhận được khi biên dịch code này:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/listing-20-22/output.txt}}
</code></pre>
<p>Lỗi này cho chúng ta biết rằng không thể gọi <code>join</code> vì chúng ta chỉ có một
tham chiếu thay đổi (<code>mutable borrow</code>) tới mỗi <code>worker</code>, trong khi <code>join</code>
yêu cầu quyền sở hữu (<code>ownership</code>) của đối số. Để giải quyết vấn đề này,
chúng ta cần di chuyển thread ra khỏi instance <code>Worker</code> đang sở hữu <code>thread</code>
để <code>join</code> có thể tiêu thụ thread đó. Chúng ta đã làm điều này trong Listing 17-15:
nếu <code>Worker</code> giữ một <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, chúng ta có thể gọi
phương thức <code>take</code> trên <code>Option</code> để di chuyển giá trị ra khỏi biến <code>Some</code>
và để lại <code>None</code> ở vị trí đó. Nói cách khác, một <code>Worker</code> đang chạy sẽ có
biến <code>Some</code> trong <code>thread</code>, và khi muốn dọn dẹp một <code>Worker</code>, chúng ta sẽ
thay <code>Some</code> bằng <code>None</code> để <code>Worker</code> không còn thread nào để chạy.</p>
<p>Vì vậy, chúng ta biết rằng cần cập nhật định nghĩa của <code>Worker</code> như sau:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/no-listing-04-update-worker-definition/src/lib.rs:here}}</code></pre>
<p>Bây giờ chúng ta hãy dựa vào compiler để tìm các chỗ khác cần thay đổi.
Khi kiểm tra mã này, chúng ta nhận được hai lỗi:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/no-listing-04-update-worker-definition/output.txt}}
</code></pre>
<p>Hãy giải quyết lỗi thứ hai, liên quan đến mã ở cuối <code>Worker::new</code>; chúng ta cần
bao <code>thread</code> trong <code>Some</code> khi tạo một <code>Worker</code> mới. Thực hiện các thay đổi sau
để sửa lỗi này:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/no-listing-05-fix-worker-new/src/lib.rs:here}}</code></pre>
<p>Lỗi đầu tiên nằm trong phần triển khai <code>Drop</code>. Chúng ta đã đề cập trước đó rằng
chúng ta dự định gọi <code>take</code> trên giá trị <code>Option</code> để di chuyển <code>thread</code> ra khỏi
<code>worker</code>. Các thay đổi sau sẽ thực hiện điều đó:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">{{#rustdoc_include ../listings/ch20-web-server/no-listing-06-fix-threadpool-drop/src/lib.rs:here}}</code></pre>
<p>Như đã thảo luận trong Chương 17, phương thức <code>take</code> trên <code>Option</code> sẽ lấy giá trị
<code>Some</code> ra và để lại <code>None</code> ở chỗ đó. Chúng ta dùng <code>if let</code> để phá cấu trúc
<code>Some</code> và lấy ra <code>thread</code>; sau đó gọi <code>join</code> trên <code>thread</code> đó. Nếu <code>thread</code> của
một worker đã là <code>None</code>, nghĩa là worker đó đã được dọn dẹp trước, nên trong
trường hợp này sẽ không có gì xảy ra.</p>
<h3 id="thông-báo-cho-các-thread-dừng-lắng-nghe-job"><a class="header" href="#thông-báo-cho-các-thread-dừng-lắng-nghe-job">Thông báo cho các Thread dừng lắng nghe Job</a></h3>
<p>Với tất cả những thay đổi trên, code của chúng ta đã biên dịch mà không có cảnh báo.
Tuy nhiên, vấn đề là code hiện tại vẫn chưa hoạt động đúng như mong muốn.
Điểm then chốt nằm ở logic trong các closure mà các thread của <code>Worker</code> đang chạy:
hiện tại chúng ta chỉ gọi <code>join</code>, nhưng điều này sẽ không tắt các thread
bởi vì chúng <code>loop</code> vô tận để chờ job. Nếu thử <code>drop</code> <code>ThreadPool</code> với
cách triển khai hiện tại, thread chính sẽ bị block vô thời hạn chờ thread đầu tiên kết thúc.</p>
<p>Để khắc phục vấn đề này, chúng ta cần thay đổi trong triển khai <code>drop</code> của
<code>ThreadPool</code> và thay đổi trong vòng lặp của <code>Worker</code>.</p>
<p>Trước tiên, chúng ta sẽ thay đổi <code>drop</code> của <code>ThreadPool</code> để chủ động
<code>drop</code> <code>sender</code> trước khi chờ các thread hoàn tất. Listing 20-23 minh họa
các thay đổi trong <code>ThreadPool</code> để chủ động <code>drop</code> <code>sender</code>. Chúng ta sử dụng
cùng kỹ thuật <code>Option</code> và <code>take</code> như với thread để có thể di chuyển <code>sender</code>
ra khỏi <code>ThreadPool</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior">{{#rustdoc_include ../listings/ch20-web-server/listing-20-23/src/lib.rs:here}}</code></pre>
<p>Việc <code>drop</code> <code>sender</code> sẽ đóng kênh, báo hiệu rằng sẽ không còn thông điệp nào
được gửi nữa. Khi điều này xảy ra, tất cả các lần gọi <code>recv</code> trong vòng lặp
vô hạn của các worker sẽ trả về lỗi. Trong Listing 20-24, chúng ta thay đổi
vòng lặp của <code>Worker</code> để thoát vòng lặp một cách an toàn khi nhận lỗi,
nghĩa là các thread sẽ kết thúc khi <code>ThreadPool</code> gọi <code>join</code> trên chúng.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-24/src/lib.rs:here}}</code></pre>
<p><span class="caption">Listing 20-24: Thoát vòng lặp một cách rõ ràng khi <code>recv</code> trả về lỗi</span></p>
<p>Để thấy đoạn code này hoạt động, hãy chỉnh sửa <code>main</code> sao cho server chỉ nhận tối đa hai request
trước khi đóng server một cách gọn gàng, như minh họa trong Listing 20-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch20-web-server/listing-20-25/src/main.rs:here}}</code></pre>
<p><span class="caption">Listing 20-25: Tắt server sau khi phục vụ hai request bằng cách thoát khỏi vòng lặp</span></p>
<p>Trong thực tế, bạn sẽ không muốn một web server tắt sau khi
chỉ phục vụ hai request. Đoạn code này chỉ nhằm minh họa
rằng cơ chế tắt server gọn gàng và dọn dẹp tài nguyên đang hoạt động.</p>
<p>Phương thức <code>take</code> được định nghĩa trong trait <code>Iterator</code>
và giới hạn số lần lặp tối đa là hai. <code>ThreadPool</code> sẽ ra khỏi phạm vi
khi kết thúc <code>main</code>, và implementation của <code>drop</code> sẽ được gọi.</p>
<p>Chạy server bằng <code>cargo run</code>, và gửi ba request. Request thứ ba sẽ gặp lỗi,
và trên terminal bạn sẽ thấy đầu ra tương tự như sau:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Bạn có thể thấy thứ tự in ra của các worker và các message sẽ khác nhau.
Chúng ta có thể hiểu cách hoạt động của đoạn code này qua các thông báo:
worker 0 và 3 nhận hai request đầu tiên. Server ngừng chấp nhận kết nối
sau kết nối thứ hai, và implementation của <code>Drop</code> trên <code>ThreadPool</code>
bắt đầu thực thi trước khi worker 3 kịp bắt đầu công việc của nó.
Việc drop <code>sender</code> sẽ ngắt kết nối tất cả các worker và báo cho chúng tắt.
Mỗi worker sẽ in ra một thông báo khi chúng bị ngắt kết nối,
sau đó thread pool gọi <code>join</code> để chờ các thread worker kết thúc.</p>
<p>Lưu ý một điểm thú vị trong lần thực thi này: <code>ThreadPool</code> drop <code>sender</code>,
và trước khi bất kỳ worker nào nhận được lỗi, chúng ta đã thử join worker 0.
Worker 0 chưa nhận lỗi từ <code>recv</code>, nên thread chính bị chặn chờ worker 0 hoàn thành.
Trong lúc đó, worker 3 nhận được một job và sau đó tất cả các thread nhận lỗi.
Khi worker 0 kết thúc, thread chính chờ các worker còn lại hoàn thành.
Lúc đó, tất cả đã thoát khỏi vòng lặp và dừng lại.</p>
<p>Chúc mừng! Chúng ta đã hoàn thành dự án; chúng ta có một web server
cơ bản sử dụng thread pool để phản hồi bất đồng bộ.
Chúng ta có thể thực hiện tắt server một cách gọn gàng, dọn dẹp tất cả các thread trong pool.</p>
<p>Dưới đây là toàn bộ code để tham khảo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-final-code/src/main.rs}}</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-final-code/src/lib.rs}}</code></pre>
<p>Chúng ta vẫn có thể làm nhiều hơn nữa! Nếu bạn muốn tiếp tục cải tiến dự án này, đây là một số ý tưởng:</p>
<ul>
<li>Thêm nhiều tài liệu hơn cho <code>ThreadPool</code> và các phương thức public của nó.</li>
<li>Thêm các bài test cho chức năng của thư viện.</li>
<li>Thay các lần gọi <code>unwrap</code> bằng cơ chế xử lý lỗi chắc chắn hơn.</li>
<li>Sử dụng <code>ThreadPool</code> để thực hiện một nhiệm vụ khác ngoài việc phục vụ web request.</li>
<li>Tìm một crate thread pool trên <a href="https://crates.io/">crates.io</a> và triển khai một web server tương tự bằng crate đó. Sau đó so sánh API và độ ổn định với thread pool mà chúng ta tự implement.</li>
</ul>
<h2 id="tóm-tắt"><a class="header" href="#tóm-tắt">Tóm tắt</a></h2>
<p>Xuất sắc! Bạn đã đi đến cuối cuốn sách! Chúng tôi cảm ơn bạn
đã đồng hành cùng chúng tôi trong chuyến tham quan Rust.
Bây giờ bạn đã sẵn sàng để triển khai các dự án Rust của riêng mình
và hỗ trợ các dự án của người khác. Hãy nhớ rằng cộng đồng Rustacean
luôn chào đón và sẵn sàng giúp bạn vượt qua bất kỳ thử thách nào trên hành trình học Rust của bạn.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-multithreaded.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="appendix-00.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-multithreaded.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="appendix-00.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
