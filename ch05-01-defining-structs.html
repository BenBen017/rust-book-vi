<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Định nghĩa và khởi tạo Struct - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Định-nghĩa-và-khởi-tạo-các-cấu-trúc"><a class="header" href="#Định-nghĩa-và-khởi-tạo-các-cấu-trúc">Định nghĩa và khởi tạo các cấu trúc</a></h2>
<p>Struct (cấu trúc) tương tự như tuple, được thảo luận trong phần <a href="ch03-02-data-types.html#the-tuple-type">“The Tuple Type”</a><!--
ignore -->, trong đó cả hai đều chứa những giá trị liên quan. Giống như các tuple, các
các phần của một cấu trúc có thể là các kiểu khác nhau. Không giống như với tuple, trong một cấu trúc
bạn sẽ đặt tên cho từng phần dữ liệu để hiểu rõ ý nghĩa của các giá trị. Việc thêm tên
cho những thành phần bên trong giúp nó có cấu trúc linh hoạt hơn tuple: bạn không cần phải dựa vào
thứ tự của dữ liệu để truy cập vào các giá trị của một instance (thể hiện).</p>
<p>Để định nghĩa một struct, chúng ta nhập từ khóa <code>struct</code> và đặt tên cho toàn bộ struct.
Tên của một cấu trúc phải mô tả mục đích quan trọng nhất của phần dữ liệu nó chứa. Sau đó, bên trong dấu
ngoặc nhọn, chúng ta xác định tên và kiểu của các phần dữ liệu mà chúng tôi gọi là <em>field</em> (trường).
Ví dụ, Listing 5-1 cho thấy một struct lưu trữ thông tin về tài khoản người dùng.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 5-1: Định nghĩa cấu trúc <code>User</code></span></p>
<p>Để sử dụng một struct sau khi đã định nghĩa, chúng ta tạo một <em>instance</em> của cấu trúc đó
bằng cách chỉ định các giá trị cụ thể cho từng trường. Chúng tôi tạo một ví dụ bằng cách
nêu tên của cấu trúc và sau đó thêm dấu ngoặc nhọn chứa các cặp <em>key:value</em>,
trong đó các key là tên của các field và các value là dữ liệu chúng ta muốn
lưu trong các trường đó. Chúng ta không phải chỉ định các field theo
cùng thứ tự mà chúng ta đã khai báo chúng trong cấu trúc. Nói cách khác, một
định nghĩa cấu trúc giống như một hình mẫu chung cho một kiểu và các instance
gán vào trong hình mẫu đó các dữ liệu cụ thể để tạo các giá trị của kiểu.
Ví dụ, chúng ta có thể khai báo một user cụ thể như trong Listing 5-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-2: Tạo một instance của cấu trúc <code>User</code></span></p>
<p>Để lấy một giá trị cụ thể từ một struct, chúng ta sử dụng ký hiệu dấu chấm. Ví dụ, để
truy cập địa chỉ email của user này, chúng ta sử dụng <code>user1.email</code>. Nếu instance là
mutable (có thể thay đổi), chúng ta có thể thay đổi một giá trị bằng cách sử dụng
ký hiệu dấu chấm và gán vào một field cụ thể. Listing kê 5-3 cho thấy cách
thay đổi giá trị trong field <code>email</code> của một mutable instance <code>User</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
<p><span class="caption">Listing 5-3: Thay đổi giá trị trường <code>email</code> của một instance <code>User</code></span></p>
<p>Lưu ý rằng toàn bộ instance phải mutable; Rust không cho phép chúng ta đánh dấu
chỉ một số trường nhất định là mutable. Như với bất kỳ biểu thức nào, chúng ta
có thể tạo một instance mới của cấu trúc với biểu thức cuối cùng trong thân hàm
để trả lại một cách rõ ràng instance mới đó.</p>
<p>Listing 5-4 biểu diễn một hàm <code>build_user</code> trả về một instance kiểu <code>User</code> với
email và tên người dùng đã cho. Trường <code>active</code> nhận giá trị <code>true</code> và
<code>sign_in_count</code> nhận giá trị <code>1</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-4: Một hàm <code>build_user</code> nhận vào một email và
username và trả về một <code>User</code> instance</span></p>
<p>Sẽ là có nghĩa khi đặt tên các tham số của function với tên trùng với tên các
trường của struct, nhưng việc lặp lại các tên như <code>email</code> và <code>username</code> cũng sẽ
gây nhàm chán. Nếu struct có thêm nhiều field nữa, việc lặp đi lặp lại chúng sẽ
còn gây khó chịu hơn. May thay, Rust có một cách viết ngắn gọn!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="sử-dụng-cách-viết-khởi-tạo-trường-một-cách-ngắn-gọn"><a class="header" href="#sử-dụng-cách-viết-khởi-tạo-trường-một-cách-ngắn-gọn">Sử dụng cách viết khởi tạo trường một cách ngắn gọn</a></h3>
<p>Vì tên tham số và tên trường của cấu trúc hoàn toàn giống nhau trong
Listing 5-4, chúng ta có thể sử dụng cú pháp tốc ký <em>field init</em> để viết lại
<code>build_user</code> giúp nó hoạt động giống hệt nhưng không có sự lặp lại của
<code>username</code> và <code>email</code>, như trong Listing 5-5.</p>
<p><span class="filename">Tên tệp: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-5: Hàm <code>build_user</code> sử dụng cách viết tắt để khởi tạo
vì tham số <code>username</code> và <code>email</code> có cùng tên với field</span></p>
<p>Ở đây, chúng ta tạo một instance mới của cấu trúc <code>User</code>, có field
tên là <code>email</code>. Chúng ta muốn đặt giá trị của <code>email</code> thành giá trị trong
tham số <code>email</code> của hàm <code>build_user</code>. Vì trường <code>email</code> và
tham số <code>email</code> trùng tên ta chỉ cần viết <code>email</code> là được
hơn <code>email: email</code>.</p>
<p><a id="creating-instances-from-other-instances-with-struct-update-syntax"></a></p>
<h3 id="tạo-instance-mới-từ-một-instance-khác-với-cú-pháp-cập-nhật-cấu-trúc"><a class="header" href="#tạo-instance-mới-từ-một-instance-khác-với-cú-pháp-cập-nhật-cấu-trúc">Tạo instance mới từ một instance khác với cú pháp cập nhật cấu trúc</a></h3>
<p>Một thao tác thường làm là tạo mới một instance của Struct với hầu hết
các giá trị từ một phiên bản khác, với một số thay đổi. Bạn có thể làm điều này bằng cách sử dụng
<em>cú pháp cập nhật cấu trúc</em> (struct update syntax).</p>
<p>Đầu tiên, trong Listing 5-6, chúng tôi trình bày cách tạo một instance <code>User</code> mới trong <code>user2</code>
theo cách thông thường, không dùng cú pháp cập nhật. Chúng tôi đặt một giá trị mới cho <code>email</code> nhưng
sử dụng cùng các giá trị khác từ <code>user1</code> mà chúng ta đã tạo trong Listing 5-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-6: Tạo một instance <code>User</code> mới dùng giá trị từ  <code>user1</code></span></p>
<p>Sử dụng struct update syntax, chúng ta có thể đạt được cùng mục đích với ít code hơn, như thể
hiện trong Listing 5-7. Cú pháp <code>..</code> chỉ định rằng các trường còn lại không
được đặt rõ ràng phải có cùng giá trị với các trường trong instance đã cho.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-7: Sử dụng struct update syntax để đặt mới
giá trị <code>email</code> cho instance <code>User</code> nhưng sử dụng phần còn lại của các giá trị từ
<code>user1</code></span></p>
<p>Đoạn code trong Listing 5-7 cũng tạo một instance trong <code>user2</code> với một giá trị khác trong
<code>email</code> nhưng có cùng giá trị trong <code>username</code>, <code>active</code>, và <code>sign_in_count</code> từ<code>user1</code>.
<code>..user1</code> phải được viết cuối cùng để chỉ định rằng mọi trường còn lại sẽ nhận giá trị của chúng từ
các trường tương ứng trong <code>user1</code>, nhưng chúng ta có thể chọn chỉ định giá trị cho
nhiều trường như chúng ta muốn theo bất kỳ thứ tự nào, bất kể thứ tự của chúng trong
định nghĩa của cấu trúc.</p>
<p>Lưu ý rằng cú pháp cập nhật cấu trúc sử dụng <code>=</code> như một phép gán; điều này là bởi vì
nó di chuyển dữ liệu, giống như chúng ta đã thấy trong phần <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">“Variables and Data Interacting with
Move”</a><!-- ignore -->. Trong ví dụ này, chúng ta không còn có thể sử dụng
<code>user1</code> sau khi tạo <code>user2</code> vì <code>String</code> trong Trường <code>username</code> của <code>user1</code> đã
được chuyển vào <code>user2</code>. Nếu chúng ta gán <code>user2</code> một giá trị <code>String</code> mới cho cả trường <code>email</code>
và <code>username</code>, có nghĩa là ta chỉ lấy <code>active</code> và <code>sign_in_count</code> từ <code>user1</code>, khi đó
<code>user1</code> vẫn hợp lệ sau khi tạo <code>user2</code>. Đó là vì cả hai <code>active</code> và <code>sign_in_count</code>
đều implement <code>Copy</code> trait, do vậy các hành vi như ta đã thảo luậ trong phần
<a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data: Copy”</a><!-- ignore --> sẽ được áp dụng.</p>
<p><a id="using-tuple-structs-without-named-fields-to-create-different-types"></a></p>
<h3 id="sử-dụng-tuple-struct-không-dùng-các-trường-được-đặt-tên-để-tạo-các-kiểu-khác"><a class="header" href="#sử-dụng-tuple-struct-không-dùng-các-trường-được-đặt-tên-để-tạo-các-kiểu-khác">Sử dụng tuple struct không dùng các trường được đặt tên để tạo các kiểu khác</a></h3>
<p>Rust cũng hỗ trợ các cấu trúc trông tương tự như các tuple, được gọi là <em>tuple structs</em>.
Các tuple struct cho phép cung cấp tên cho cấu trúc nhưng không có các tên được kết hợp với từng
trường bên trong struct; thay vì vậy, chúng chỉ có các kiểu cho các field đó.
Các tuple struct rất hữu ích khi bạn muốn đặt tên cho toàn bộ tuple và biến nó thành
một kiểu khác với các tuple khác, và khi đặt tên cho từng field bên trong struct
như trong một cấu trúc thông thường sẽ trở nên dài dòng hoặc dư thừa.</p>
<p>Để định nghĩa tuple struct, hãy bắt đầu với từ khóa <code>struct</code> và tên cấu trúc
theo sau là các kiểu trong tuple. Ví dụ, ở đây chúng ta định nghĩa và sử dụng hai
tuple struct có tên <code>Color</code> và <code>Point</code>:</p>
<p>Rust cũng hỗ trợ các cấu trúc trông giống như các bộ dữ liệu, được gọi là <em>tuple structs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Lưu ý rằng các giá trị <code>black</code> và <code>origin</code> có các kiểu khác nhau vì chúng
là instance của các tuple struct khác nhau. Mỗi struct bạn định nghĩa mang kiểu riêng của nó,
mặc dù các trường trong struct có thể có cùng loại. Ví dụ, một hàm nhận tham số kiểu <code>Color</code> không thể nhận
<code>Point</code> làm đối số, mặc dù cả hai loại đều được tạo thành từ ba giá trị <code>i32</code>.
Mặt khác, các instance tuple struct tương tự như tuple ở chỗ bạn có thể
hủy struct chúng thành các phần riêng lẻ và bạn có thể sử dụng dấu <code>.</code> theo sau
theo chỉ mục để truy cập từng giá trị riêng.</p>
<h3 id="các-cấu-trúc-unit-like-không-có-bất-kỳ-trường-nào"><a class="header" href="#các-cấu-trúc-unit-like-không-có-bất-kỳ-trường-nào">Các cấu trúc Unit-Like không có bất kỳ trường nào</a></h3>
<p>Bạn cũng có thể định nghĩa các cấu trúc không có bất kỳ trường nào! Chúng được gọi là
<em>unit-like struct</em> vì chúng hoạt động tương tự như <code>()</code>, kiểu đơn vị
chúng ta đã đề cập trong phần <a href="ch03-02-data-types.html#the-tuple-type">“The Tuple Type”</a><!-- ignore -->. Unit-like
struct có thể hữu ích khi bạn cần triển khai một trait trên một số kiểu nhưng không
có bất kỳ dữ liệu nào mà bạn muốn lưu trữ trong chính kiểu đó. Chúng ta sẽ thảo luận về trait
trong Chương 10. Đây là một ví dụ về khai báo và khởi tạo một unit struct
được đặt tên là <code>AlwaysEqual</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>Để định nghĩa <code>AlwaysEqual</code>, chúng ta sử dụng từ khóa <code>struct</code>, tên chúng ta muốn và
sau đó là dấu chấm phẩy. Không cần dấu ngoặc nhọn hoặc dấu ngoặc đơn!
Sau đó, chúng ta có thể nhận được một instance về <code>AlwaysEqual</code> trong biến <code>subject</code>
theo cách tương tự: sử dụng tên chúng ta đã xác định, không có bất kỳ dấu ngoặc
nhọn hoặc dấu ngoặc đơn nào. Hãy tưởng tượng rằng sau này chúng tôi sẽ triển khai
hành vi cho kiểu này sao cho mọi instance của <code>AlwaysEqual</code> luôn bằng với mọi instance
của bất kỳ kiểu nào khác, có lẽ để có một kết quả xác định nhằm mục đích thử nghiệm.
Chúng ta sẽ không cần bất kỳ dữ liệu nào để thực hiện hành vi đó! Bạn sẽ thấy trong
Chương 10 cách định nghĩa các trait và triển khai chúng trên bất kỳ kiểu dữ liệu nào,
kể cả các unit-like struct.</p>
<section class="note" aria-role="note">
<h3 id="sở-hữu-của-các-cấu-trúc-dữ-liệu"><a class="header" href="#sở-hữu-của-các-cấu-trúc-dữ-liệu">Sở hữu của các cấu trúc dữ liệu</a></h3>
<p>Trong định nghĩa cấu trúc <code>User</code> trong Listing 5-1, chúng ta đã sử dụng kiểu <code>String</code>
type thay vì kiểu string slice <code>&amp;str</code>. Đây là một sự lựa chọn có chủ ý
bởi vì chúng ta muốn mỗi instance của cấu trúc này sở hữu tất cả dữ liệu của nó và cho
dữ liệu đó là hợp lệ miễn sao toàn bộ cấu trúc là hợp lệ.</p>
<p>Các cấu trúc cũng có thể lưu trữ các tham chiếu đến dữ liệu thuộc sở hữu của một thứ gì đó
khác, nhưng để làm như vậy yêu cầu sử dụng <em>lifetimes</em>, một tính năng của Rust mà chúng ta sẽ
thảo luận trong Chương 10. <em>lifetimes</em> đảm bảo rằng dữ liệu được tham chiếu bởi một cấu trúc
sẽ là hợp lệ cùng với chính cấu trúc đó . Giả sử bạn cố gắng lưu trữ một tham chiếu
trong một cấu trúc mà không chỉ định thời gian tồn tại giống như sau; chúng sẽ không hoạt động:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
<p>Trình duyệt sẽ báo lỗi rằng bạn cần các khai báo về lifetime:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>Trong chương 10, chúng ta sẽ thảo luận cách sửa các lỗi trên, cho phép bạn
lưu các tham chiếu bên trong các struct, nhưng hiện tại, chúng ta sẽ sửa các
lỗi này bằng cách dùng các kiểu được sở hữu như <code>String</code> thay vì dùng tham
chiếu như <code>&amp;str</code>.</p>
</section>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
