## Nhận Tham Số Dòng Lệnh

Hãy tạo một dự án mới bằng cách dùng, như thường lệ, `cargo new`. Chúng ta sẽ gọi dự án này là
`minigrep` để phân biệt với công cụ `grep` mà bạn có thể đã có
trên hệ thống của mình.

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

Nhiệm vụ đầu tiên là làm cho `minigrep` nhận hai tham số dòng lệnh: đường dẫn tệp và một chuỗi để tìm kiếm. Tức là, chúng ta muốn có thể chạy chương trình của mình bằng `cargo run`, với hai dấu gạch ngang để chỉ ra rằng các tham số sau là dành cho chương trình của chúng ta chứ không phải cho `cargo`, một chuỗi để tìm kiếm, và một đường dẫn tới tệp để tìm kiếm, như sau:

```console
$ cargo run -- searchstring example-filename.txt
```

Right now, the program generated by `cargo new` cannot process arguments we
give it. Some existing libraries on [crates.io](https://crates.io/) can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.

### Đọc Giá Trị Tham Số

Để cho phép `minigrep` đọc các giá trị của tham số dòng lệnh mà chúng ta truyền vào, chúng ta sẽ cần hàm `std::env::args` được cung cấp trong thư viện chuẩn của Rust. Hàm này trả về một iterator của các tham số dòng lệnh được truyền cho `minigrep`. Chúng ta sẽ tìm hiểu kỹ về iterator trong [Chương 13][ch13]<!-- ignore -->. Hiện tại, bạn chỉ cần biết hai chi tiết về iterator: iterator sinh ra một chuỗi các giá trị, và chúng ta có thể gọi phương thức `collect` trên một iterator để biến nó thành một tập hợp, chẳng hạn như vector, chứa tất cả các phần tử mà iterator tạo ra.

Mã trong Listing 12-1 cho phép chương trình `minigrep` của bạn đọc bất kỳ tham số dòng lệnh nào được truyền vào và sau đó thu thập các giá trị đó vào một vector.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```

<span class="caption">Listing 12-1: Thu thập các tham số dòng lệnh vào một vector và in chúng ra</span>

Trước tiên, chúng ta đưa module `std::env` vào phạm vi với câu lệnh `use` để có thể sử dụng hàm `args` của nó. Lưu ý rằng hàm `std::env::args` được lồng trong hai cấp module. Như chúng ta đã thảo luận trong [Chương 7][ch7-idiomatic-use]<!-- ignore -->, trong những trường hợp hàm cần dùng được lồng trong nhiều module, chúng ta chọn cách đưa module cha vào phạm vi thay vì đưa trực tiếp hàm. Bằng cách này, chúng ta có thể dễ dàng sử dụng các hàm khác từ `std::env`. Cách này cũng ít gây nhầm lẫn hơn so với việc thêm `use std::env::args` và sau đó gọi hàm chỉ với `args`, vì `args` có thể dễ bị nhầm với một hàm được định nghĩa trong module hiện tại.

> ### Hàm `args` và Unicode không hợp lệ
>
> Lưu ý rằng `std::env::args` sẽ gây panic nếu bất kỳ tham số nào chứa Unicode không hợp lệ. Nếu chương trình của bạn cần chấp nhận các tham số chứa Unicode không hợp lệ, hãy dùng `std::env::args_os` thay thế. Hàm này trả về một iterator tạo ra các giá trị `OsString` thay vì `String`. Ở đây, chúng ta chọn sử dụng `std::env::args` để đơn giản, vì các giá trị `OsString` khác nhau tùy theo nền tảng và phức tạp hơn khi làm việc so với `String`.

Ở dòng đầu tiên của `main`, chúng ta gọi `env::args`, và ngay lập tức dùng `collect` để biến iterator thành một vector chứa tất cả các giá trị mà iterator sinh ra. Chúng ta có thể dùng hàm `collect` để tạo nhiều loại tập hợp khác nhau, vì vậy chúng ta chú thích rõ kiểu của `args` để chỉ ra rằng chúng ta muốn một vector các chuỗi. Mặc dù hiếm khi cần chú thích kiểu trong Rust, `collect` là một trong những hàm mà bạn thường phải chú thích, vì Rust không thể suy ra loại tập hợp bạn muốn.

Cuối cùng, chúng ta in vector ra bằng macro debug. Hãy thử chạy mã trước tiên không có tham số, rồi sau đó với hai tham số:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

Lưu ý rằng giá trị đầu tiên trong vector là `"target/debug/minigrep"`, chính là tên của file nhị phân của chúng ta. Điều này khớp với hành vi của danh sách tham số trong C, cho phép chương trình sử dụng tên mà chúng được gọi khi thực thi. Thường thì việc có quyền truy cập vào tên chương trình rất tiện lợi nếu bạn muốn in nó trong các thông báo hoặc thay đổi hành vi của chương trình dựa trên alias dòng lệnh được dùng để gọi chương trình. Nhưng trong chương này, chúng ta sẽ bỏ qua giá trị này và chỉ lưu hai tham số mà chúng ta cần.

### Lưu Giá Trị Tham Số vào Biến

Chương trình hiện tại đã có thể truy cập các giá trị được chỉ định dưới dạng tham số dòng lệnh. Bây giờ chúng ta cần lưu giá trị của hai tham số vào các biến để có thể sử dụng chúng trong suốt phần còn lại của chương trình. Chúng ta thực hiện việc này trong Listing 12-2.

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```

<span class="caption">Listing 12-2: Tạo các biến để lưu tham số truy vấn và tham số đường dẫn tệp</span>

Như chúng ta đã thấy khi in vector, tên chương trình chiếm giá trị đầu tiên trong vector tại `args[0]`, vì vậy chúng ta bắt đầu các tham số từ chỉ số `1`. Tham số đầu tiên mà `minigrep` nhận là chuỗi mà chúng ta muốn tìm kiếm, vì vậy chúng ta đặt một tham chiếu tới tham số đầu tiên vào biến `query`. Tham số thứ hai sẽ là đường dẫn tệp, nên chúng ta đặt một tham chiếu tới tham số thứ hai vào biến `file_path`.

Chúng ta tạm thời in các giá trị của những biến này để chứng minh rằng mã hoạt động như mong muốn. Hãy chạy lại chương trình này với các tham số `test` và `sample.txt`:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

Tuyệt vời, chương trình hoạt động rồi! Các giá trị của các tham số mà chúng ta cần đang được lưu vào các biến đúng. Sau này chúng ta sẽ thêm một số xử lý lỗi để đối phó với một số tình huống có thể xảy ra, chẳng hạn như khi người dùng không cung cấp tham số; hiện tại, chúng ta sẽ bỏ qua tình huống đó và tập trung vào việc thêm khả năng đọc tệp.

[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
