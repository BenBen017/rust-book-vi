## `Rc<T>`, Smart Pointer Đếm Tham Chiếu

Trong hầu hết các trường hợp, quyền sở hữu rõ ràng: bạn biết chính xác biến nào sở hữu một giá trị nhất định. Tuy nhiên, có những trường hợp một giá trị có thể có nhiều chủ sở hữu. Ví dụ, trong các cấu trúc dữ liệu đồ thị, nhiều cạnh có thể trỏ đến cùng một nút, và nút đó về mặt khái niệm được sở hữu bởi tất cả các cạnh trỏ tới nó. Một nút không nên bị dọn dẹp trừ khi không còn cạnh nào trỏ tới nó và do đó không còn chủ sở hữu.

Bạn phải cho phép sở hữu nhiều chủ sở hữu một cách rõ ràng bằng cách sử dụng kiểu Rust `Rc<T>`, viết tắt của *reference counting* (đếm tham chiếu). Kiểu `Rc<T>` theo dõi số lượng tham chiếu tới một giá trị để xác định xem giá trị đó còn đang được sử dụng hay không. Nếu không còn tham chiếu nào tới giá trị, giá trị có thể được dọn dẹp mà không làm invalid bất kỳ tham chiếu nào.

Hãy tưởng tượng `Rc<T>` giống như một TV trong phòng khách gia đình. Khi một người vào xem TV, họ bật TV lên. Những người khác có thể vào phòng và xem TV. Khi người cuối cùng rời phòng, họ tắt TV vì TV không còn được sử dụng nữa. Nếu ai đó tắt TV trong khi những người khác vẫn đang xem, sẽ có sự phản đối từ những người còn lại!

Chúng ta sử dụng kiểu `Rc<T>` khi muốn cấp phát dữ liệu trên heap để nhiều phần của chương trình đọc và không thể xác định tại thời điểm biên dịch phần nào sẽ sử dụng dữ liệu xong trước. Nếu biết phần nào sử dụng xong cuối cùng, chúng ta có thể chỉ định phần đó làm chủ sở hữu dữ liệu, và các quy tắc ownership thông thường được kiểm tra tại thời điểm biên dịch sẽ có hiệu lực.

Lưu ý rằng `Rc<T>` chỉ dùng trong các tình huống đơn luồng. Khi thảo luận về đa luồng trong Chương 16, chúng ta sẽ đề cập cách đếm tham chiếu trong các chương trình đa luồng.

### Sử dụng `Rc<T>` để Chia Sẻ Dữ Liệu

Hãy quay lại ví dụ danh sách cons trong Listing 15-5. Nhớ rằng chúng ta đã định nghĩa nó sử dụng `Box<T>`. Lần này, chúng ta sẽ tạo hai danh sách cùng chia sẻ quyền sở hữu của một danh sách thứ ba. Về mặt khái niệm, điều này tương tự như Hình 15-3:

<img alt="Hai danh sách chia sẻ quyền sở hữu của danh sách thứ ba" src="img/trpl15-03.svg" class="center" />

<span class="caption">Hình 15-3: Hai danh sách, `b` và `c`, cùng chia sẻ quyền sở hữu của danh sách thứ ba, `a`</span>

Chúng ta sẽ tạo danh sách `a` chứa các giá trị 5 và 10. Sau đó, tạo thêm hai danh sách: `b` bắt đầu với 3 và `c` bắt đầu với 4. Cả hai danh sách `b` và `c` sau đó sẽ tiếp nối danh sách `a` ban đầu chứa 5 và 10. Nói cách khác, cả hai danh sách sẽ cùng chia sẻ danh sách đầu tiên chứa 5 và 10.

Cố gắng thực hiện kịch bản này sử dụng định nghĩa `List` với `Box<T>` sẽ không hoạt động, như được minh họa trong Listing 15-17:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

<span class="caption">Listing 15-17: Minh họa việc không được phép có hai danh sách sử dụng `Box<T>` mà cố gắng chia sẻ quyền sở hữu của một danh sách thứ ba</span>

Khi biên dịch mã này, chúng ta nhận được lỗi sau:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

Các biến thể `Cons` sở hữu dữ liệu mà chúng giữ, vì vậy khi chúng ta tạo danh sách `b`, `a` sẽ bị **di chuyển** vào `b` và `b` sở hữu `a`. Sau đó, khi chúng ta cố gắng sử dụng lại `a` để tạo `c`, điều đó không được phép vì `a` đã bị di chuyển.

Chúng ta có thể thay đổi định nghĩa của `Cons` để giữ các **tham chiếu** thay vì giá trị sở hữu, nhưng khi đó chúng ta phải khai báo các tham số **lifetime**. Khi khai báo lifetime, chúng ta sẽ chỉ định rằng mỗi phần tử trong danh sách sẽ sống ít nhất bằng toàn bộ thời gian sống của danh sách. Điều này đúng với các phần tử và danh sách trong Listing 15-17, nhưng không phải trong mọi trường hợp.

Thay vào đó, chúng ta sẽ thay đổi định nghĩa của `List` để sử dụng `Rc<T>` thay cho `Box<T>`, như được trình bày trong Listing 15-18. Mỗi biến thể `Cons` bây giờ sẽ giữ một giá trị và một `Rc<T>` trỏ tới một `List`. Khi tạo `b`, thay vì chiếm quyền sở hữu của `a`, chúng ta sẽ **clone** `Rc<List>` mà `a` giữ, từ đó tăng số lượng tham chiếu từ một lên hai và cho phép `a` và `b` cùng sở hữu dữ liệu trong `Rc<List>`. Chúng ta cũng sẽ clone `a` khi tạo `c`, tăng số lượng tham chiếu từ hai lên ba. Mỗi khi gọi `Rc::clone`, bộ đếm tham chiếu tới dữ liệu bên trong `Rc<List>` sẽ tăng lên, và dữ liệu sẽ không bị giải phóng cho đến khi không còn tham chiếu nào tới nó.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>

Chúng ta cần thêm câu lệnh `use` để đưa `Rc<T>` vào phạm vi sử dụng vì nó không có trong prelude. Trong `main`, chúng ta tạo danh sách chứa 5 và 10 và lưu nó vào một `Rc<List>` mới trong `a`. Sau đó, khi tạo `b` và `c`, chúng ta gọi hàm `Rc::clone` và truyền một tham chiếu tới `Rc<List>` trong `a` làm đối số.

Chúng ta có thể gọi `a.clone()` thay vì `Rc::clone(&a)`, nhưng quy ước của Rust là sử dụng `Rc::clone` trong trường hợp này. Việc triển khai `Rc::clone` không tạo một bản sao sâu của toàn bộ dữ liệu như hầu hết các kiểu dữ liệu khác triển khai `clone`. Lệnh gọi `Rc::clone` chỉ tăng bộ đếm tham chiếu, điều này tốn rất ít thời gian. Các bản sao sâu của dữ liệu có thể mất nhiều thời gian. Bằng cách sử dụng `Rc::clone` cho việc đếm tham chiếu, chúng ta có thể phân biệt rõ ràng giữa các bản sao sâu (deep-copy) và các bản sao chỉ tăng bộ đếm tham chiếu. Khi tìm kiếm vấn đề về hiệu năng trong mã, chúng ta chỉ cần xem xét các bản sao sâu và có thể bỏ qua các lệnh gọi tới `Rc::clone`.

### Cloning một `Rc<T>` làm tăng bộ đếm tham chiếu

Hãy thay đổi ví dụ đang hoạt động trong Listing 15-18 để có thể thấy được số lượng tham chiếu thay đổi khi chúng ta tạo và xóa các tham chiếu tới `Rc<List>` trong `a`.

Trong Listing 15-19, chúng ta sẽ thay đổi `main` để có một scope bên trong cho danh sách `c`; sau đó chúng ta có thể thấy số lượng tham chiếu thay đổi khi `c` ra khỏi phạm vi.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

<span class="caption">Listing 15-19: In ra số lượng tham chiếu</span>

Tại mỗi điểm trong chương trình mà số lượng tham chiếu thay đổi, chúng ta in ra số lượng tham chiếu, lấy được bằng cách gọi hàm `Rc::strong_count`. Hàm này được đặt tên là `strong_count` thay vì `count` vì kiểu `Rc<T>` cũng có `weak_count`; chúng ta sẽ tìm hiểu `weak_count` được dùng để làm gì trong phần [“Ngăn chặn chu kỳ tham chiếu: Chuyển một `Rc<T>` thành `Weak<T>`”][preventing-ref-cycles]<!-- ignore -->.
  
Mã này in ra kết quả sau:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

Chúng ta có thể thấy rằng `Rc<List>` trong `a` ban đầu có số lượng tham chiếu là 1; 
sau đó mỗi lần gọi `clone`, số lượng này tăng lên 1. Khi `c` ra khỏi phạm vi, số lượng giảm đi 1.
 Chúng ta không cần gọi một hàm nào để giảm số lượng tham chiếu như khi phải gọi `Rc::clone` 
 để tăng số lượng tham chiếu: việc triển khai trait `Drop` sẽ tự động giảm số lượng tham chiếu khi một giá trị `Rc<T>` ra khỏi phạm vi.

Điều chúng ta không thấy trong ví dụ này là khi `b` và sau đó `a` ra khỏi phạm vi vào cuối `main`,
 số lượng tham chiếu sẽ bằng 0, và `Rc<List>` được dọn dẹp hoàn toàn. Sử dụng `Rc<T>` 
 cho phép một giá trị có nhiều chủ sở hữu, và số lượng tham chiếu đảm bảo rằng giá trị 
 vẫn hợp lệ miễn là còn bất kỳ chủ sở hữu nào tồn tại.

Thông qua các tham chiếu không thay đổi, `Rc<T>` cho phép bạn chia sẻ dữ liệu giữa nhiều phần 
của chương trình chỉ để đọc. Nếu `Rc<T>` cho phép bạn có nhiều tham chiếu thay đổi cũng như vậy, 
bạn có thể vi phạm một trong các quy tắc mượn đã thảo luận trong Chương 4: nhiều lần mượn thay đổi
 cùng một vị trí có thể gây ra race condition và dữ liệu không nhất quán. 
 Nhưng khả năng thay đổi dữ liệu là rất hữu ích! Trong phần tiếp theo, chúng ta sẽ thảo luận 
 về mẫu *interior mutability* và kiểu `RefCell<T>` mà bạn có thể sử dụng cùng với `Rc<T>` để làm việc với giới hạn không thay đổi này.

[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
